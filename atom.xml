<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yiYe&#39;s Blog</title>
  
  <subtitle>YOU&#39;VE MADE A BRAVE DECISION, WELCOME.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangyiye.github.io/"/>
  <updated>2019-09-22T02:12:09.000Z</updated>
  <id>https://wangyiye.github.io/</id>
  
  <author>
    <name>yiYe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node</title>
    <link href="https://wangyiye.github.io/2019/09/22/node%E5%9F%BA%E7%A1%80/"/>
    <id>https://wangyiye.github.io/2019/09/22/node基础/</id>
    <published>2019-09-22T13:48:49.000Z</published>
    <updated>2019-09-22T02:12:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript——node"><a href="#JavaScript——node" class="headerlink" title="JavaScript——node"></a>JavaScript——node</h2><h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><blockquote><p>一个解析JS的工具，之所以称为后台语言的主要原因，我们通常把node安装在服务器端，在服务器端通过node执行一些代码，实现服务器的某些功能</p></blockquote><h3 id="npm-node-package-manager-安装NODE后自带的模块管理工具，基于此完成安装和卸载模块，bower-yarn"><a href="#npm-node-package-manager-安装NODE后自带的模块管理工具，基于此完成安装和卸载模块，bower-yarn" class="headerlink" title="npm(node package manager) 安装NODE后自带的模块管理工具，基于此完成安装和卸载模块，bower yarn"></a>npm(node package manager) 安装NODE后自带的模块管理工具，基于此完成安装和卸载模块，bower yarn</h3><p>项目架构：基于node.js构建中间层<br>特点：单线程异步/无阻塞I/O/事件驱动<br>node.js作为服务层，抗压和抗并发能力强<br><img src="/2019/09/22/node基础/1.png" alt="Alt text"><br><img src="/2019/09/22/node基础/2.png" alt="Alt text"></p><h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><p>I： input<br>O：output<br>I/O指对文件的读写操作</p><blockquote><p>JS在客户端运行，不能对客户端本地的文件进行读写操作，为了保证客户端的信息安全。<br>input：type=’file’  文件上传除外，这种需求需要客户手动自己选择。</p></blockquote><h3 id="JS在服务器端运行（基于node），可以对服务器端的文件进行操作。"><a href="#JS在服务器端运行（基于node），可以对服务器端的文件进行操作。" class="headerlink" title="JS在服务器端运行（基于node），可以对服务器端的文件进行操作。"></a>JS在服务器端运行（基于node），可以对服务器端的文件进行操作。</h3><blockquote><p>node赋予了JS进行I/O操作的能力（内置模块fs）</p></blockquote><h3 id="window-amp-global"><a href="#window-amp-global" class="headerlink" title="window &amp;global"></a>window &amp;global</h3><blockquote><p>在客户端浏览器中运行JS，JS全局对象：window（提供很多内置的属性和方法）在node中运行JS，全局对象是global，this可能是global(REPL中执行代码)，或当前模块(node xxx.js执行)</p></blockquote><ul><li>process  <pre><code>+  nextTick 下个任务+  env  node环境变量</code></pre><ul><li>buffer 文件流</li><li>setImmediate 立即执行定时器 类似于（setTimeout(func,0)</li></ul></li></ul><h3 id="NPM基础命令"><a href="#NPM基础命令" class="headerlink" title="NPM基础命令"></a>NPM基础命令</h3><ol><li>模块管理（安装和卸载）<blockquote><p>安装在全局环境下和安装在当前项目中</p></blockquote></li></ol><ul><li><p>全装在全局：<code>$ npm install xxx --global</code> （$ npm i -g xxx）</p></li><li><p>安装在本地项目中：$ npm i xxx</p><ul><li>把模块设置为开发依赖（开发中）：$ npm i xxx –save-dev</li><li>把模块设置为生产依赖（部署到服务器）：$ npm i xxx –save</li></ul></li><li><p>安装在全局和本地的区别</p><ul><li>安装在全局后对任何项目都有作用（也有可能导致版本冲突），但是只能基于命令的方式管理，不能基于CommonJS中的require导入使用（通俗说：就是不能导入到文件中基于代码来处理）<ul><li>$ npm root -g 查看全局安装到的目录</li><li>之所以可以使用命令操作，是因为在全局目录下生成了一个xxx.cmd的文件</li></ul></li><li>安装在本地默认不能基于命令管理，但是可以导入到文件中基于代码操作，只对当前项目有用</li></ul></li><li><p>在本地安装模块之前，最好先：$ npm init -y，生成package.json模块配置文件</p><ul><li><p>把安装的模块生成配置清单，存放在package.json中，后期别人需要部署项目的时候，只需要执行 $ npm i 就可以把所有的依赖项重新安装一遍 “跑环境”</p><ul><li>$ npm i 是把开发和生产依赖都安装一遍</li><li>$ npm i –production 只安装生产依赖的模块</li></ul></li><li><p>在package.json中，可以基于scripts选项配置本地可执行的脚本命令 $npm run xxx</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">//=&gt;AAA是命令，值是要做的事情</span><br><span class="line">&quot;AAA&quot;: &quot;node xxx.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置可执行脚本命令的时候，基于process的环境变量区分开发还是生产环境</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">//=&gt;set NODE_EVN=dev 设置全局环境变量（MAC下用 export NODE_EVN=dev）</span><br><span class="line">  &quot;serve&quot;: &quot;set NODE_EVN=dev&amp;&amp;node test1.js&quot;,</span><br><span class="line"> &quot;build&quot;: &quot;set NODE_EVN=pro&amp;&amp;node test1.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="CommonJS模块管理机制"><a href="#CommonJS模块管理机制" class="headerlink" title="CommonJS模块管理机制"></a>CommonJS模块管理机制</h3><blockquote><p>模块化思想规定了我们模块如何创建以及导入导出；</p></blockquote><ul><li>AMD  require.js</li><li>CMD sea.js</li><li>CommonJS   node.js  </li><li>ES6 Module  </li></ul><p><strong>内置模块</strong><br><strong>1. http/https : 创建和管理服务的模块</strong><br>        &gt; 创建服务：IIS/NGINX/APPACHE/NODE(http/https[内置模块])</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 服务器端要做的常规任务</span><br><span class="line"> *   1.创建服务：IIS/NGINX/APPACHE/NODE[HTTP/HTTPS内置模块] =&gt;端口号</span><br><span class="line"> *   2.接收客户端的请求信息（请求静态资源文件的、也有请求数据的）</span><br><span class="line"> *   3.查找到对应的资源文件内容或者对应的数据信息</span><br><span class="line"> *   4.把找到的内容返回给客户端 </span><br><span class="line"> */</span><br><span class="line">let http = require(&apos;http&apos;),</span><br><span class="line">url = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">//=&gt;HTTP.CREATE-SERVER创建服务</span><br><span class="line">let server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">//=&gt;当客户端向当前服务发送请求的时候，会触发此回调函数（请求N次，回调函数被执行N次），而且每一次都能获取本次请求的相关信息</span><br><span class="line">//req:request REQ对象中存储了客户端的请求信息</span><br><span class="line">//res:response RES对象中提供了对应的属性和方法，可以让服务器返回给客户端信息</span><br><span class="line">res.end(&apos;hello world~~&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">//=&gt;SERVER.LISTEN监听端口号</span><br><span class="line">server.listen(8080, () =&gt; &#123;</span><br><span class="line">//=&gt;当服务创建成功，并且端口号已经监听完成，触发此回调函数执行</span><br><span class="line">console.log(&apos;server is created successful！listening on 8080 port！&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"> let PORT = 80;</span><br><span class="line">function listen(PORT) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">server.listen(PORT, () =&gt; &#123;</span><br><span class="line">console.log(`服务已经基于$&#123;PORT&#125;端口启动，请勿关闭！`);</span><br><span class="line">&#125;);</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">PORT++;</span><br><span class="line">listen(PORT);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">listen(80);</span><br></pre></td></tr></table></figure><p><strong>2. fs: 给予JS进行I/O</strong><br>        + 提供属性和方法，让js在node环境下执行能够操作服务器上的资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;);</span><br><span class="line">/* ==READ-DIR== */</span><br><span class="line">//=&gt;读取指定目录（相对目录或者绝对目录都可以）中的文件目录</span><br><span class="line"> let result = fs.readdirSync(&apos;./&apos;);</span><br><span class="line"> console.log(result); //=&gt;[&quot;fs1.js&quot;,&quot;note.md&quot;,&quot;node_modules&quot;...]</span><br><span class="line"></span><br><span class="line">//异步操作是：读取成功后触发回调函数执行</span><br><span class="line"> fs.readdir(&apos;./&apos;, (err, result) =&gt; &#123;</span><br><span class="line"> //=&gt;ERR存储读取失败后的错误信息</span><br><span class="line"> //=&gt;RESULT存储读取成功后的结果（此时ERR=NULL）</span><br><span class="line"> if (err === null) &#123;</span><br><span class="line"> console.log(result);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line">/* ==READ-FILE== */</span><br><span class="line"></span><br><span class="line">//=&gt;同步或者异步读取某一个文件中的内容</span><br><span class="line">//fs.readFileSync([path],[encoding])：不设置编码格式，默认得到的是Buffer文件流（编码）格式的数据，设置UTF8，得到的结果是字符串（例如:JSON格式、HTML或者CSS等格式）；但是对于富媒体资源（例如：图片、音视频等）我们读取和传输的过程中就是基于BUFFER文件流格式操作的，所以不要设置UTF8读取；</span><br><span class="line"></span><br><span class="line">let result = fs.readFileSync(&apos;./add.png&apos;);</span><br><span class="line">console.log(result); </span><br><span class="line">fs.readFile([path],[encoding],[callback])</span><br><span class="line"> fs.readFile(&apos;./package.json&apos;, &apos;utf8&apos;, (err, result) =&gt; &#123;</span><br><span class="line">if (err !== null) return;</span><br><span class="line">console.log(result);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">/* ==WRITE-FILE== */</span><br><span class="line">//=&gt;向某个文件中写入内容（如果文件不存在，它会默认创建一个文件再写入，而且写入方式是覆盖式写入“把之前文件中的内容全部覆盖”） =&gt;appendFile是追加写入内容</span><br><span class="line">//=&gt;文件不存在可以，但是需要保证路径的正确性</span><br><span class="line">//=&gt;fs.writeFileSync([pathname],[string/buffer content],[encoding])：没有返回值</span><br><span class="line"> fs.writeFileSync(&apos;./AA.txt&apos;, &apos;你好世界~~&apos;, &apos;utf8&apos;);</span><br><span class="line">fs.appendFileSync(&apos;./AA.txt&apos;, &apos;hello world~~&apos;, &apos;utf8&apos;); </span><br><span class="line"></span><br><span class="line">//=&gt;异步操作的方式可以监听其成功或者失败</span><br><span class="line"> fs.writeFile(&apos;./AA.txt&apos;, &apos;哈哈哈~~我学会NODE了~~&apos;, &apos;utf8&apos;, err =&gt; &#123;</span><br><span class="line">console.log(err);</span><br><span class="line">&#125;); </span><br><span class="line">// fs.writeFileSync(&apos;./js/AA.txt&apos;, &apos;哈哈哈~~我学会NODE了~~&apos;, &apos;utf8&apos;); =&gt;这样会直接的报错 （可以基于try/catch异常捕获）</span><br><span class="line"> let err = null;</span><br><span class="line">try &#123;</span><br><span class="line">fs.writeFileSync(&apos;./js/AA.txt&apos;, &apos;哈哈哈~~我学会NODE了~~&apos;, &apos;utf8&apos;);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">err = e;</span><br><span class="line">&#125;</span><br><span class="line">if (err !== null) &#123;</span><br><span class="line">console.log(&apos;执行报错~~&apos;);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//=&gt;把某个文件及里面的内容拷贝到新的目录中（替换型拷贝：原来目录中存在这个文件，新拷贝的会替换原来的）</span><br><span class="line"> fs.copyFile(&apos;./AA.txt&apos;, &apos;./CC.txt&apos;, err =&gt; &#123;</span><br><span class="line">console.log(err);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">//=&gt;创建目录</span><br><span class="line"> fs.mkdir(&apos;./js&apos;, err =&gt; &#123;</span><br><span class="line">console.log(err);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">//=&gt;删除目录（但是一定要保证目录中不在有文件，否则不让删除）</span><br><span class="line">fs.rmdir(&apos;./js&apos;, err =&gt; &#123;</span><br><span class="line">console.log(err);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">//=&gt;删除文件</span><br><span class="line"></span><br><span class="line">fs.unlink(&apos;./js/1.js&apos;, err =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p><strong>3. url 解析URL地址的模块</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let url = require(&apos;url&apos;);</span><br><span class="line">//=&gt;url.parse(str,true)用来解析URL中每一部分信息的，第二个参数传TRUE，自动会把问号参数解析成键值对的方式，存储在query属性中</span><br><span class="line">// query：问号传递参数的键值对</span><br><span class="line">// pathname：请求路径名称</span><br><span class="line"></span><br><span class="line">let str = &apos;http://www.zhufengpeixun.cn:80/stu/index.html?lx=1&amp;from=weixin#teacher&apos;;</span><br><span class="line">console.log(url.parse(str, true));</span><br></pre></td></tr></table></figure><p><img src="/2019/09/22/node基础/3.png" alt="Alt text"></p><p><img src="/2019/09/22/node基础/4.png" alt="Alt text"></p><p><strong>4. path 管理路径的模块</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let path = require(&apos;path&apos;);</span><br><span class="line">let &#123;</span><br><span class="line">readFile</span><br><span class="line">&#125; = require(&apos;../utils/promiseFS&apos;);</span><br><span class="line"></span><br><span class="line">readFile(&apos;../package.json&apos;).then(result =&gt; &#123;</span><br><span class="line">console.log(result);</span><br><span class="line">&#125;).catch(reason =&gt; &#123;</span><br><span class="line">console.log(reason);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">//=&gt;获取当前模块所在的绝对路径 &quot;E:\...\js\&quot;</span><br><span class="line">// console.log(__dirname);</span><br><span class="line"></span><br><span class="line">//=&gt;获取当前NODE执行时所在的绝对目录（我们一般认为执行的目录就是项目根目录）</span><br><span class="line">// console.log(path.resolve()); //=&gt;E:\201908\第八周\20190923</span><br><span class="line">//=&gt;如果传递了一个相对目录，也是以获取的绝对目录为依托，再查找对应的目录</span><br><span class="line">// console.log(path.resolve(&apos;../package.json&apos;)); //=&gt;E:\201908\第八周\package.json</span><br></pre></td></tr></table></figure><p><strong>第三方模块</strong>  :基于<strong>npm</strong>安装的模块<br>    1. qs<br>    2. mime<br>    3. express<br>    4. express-session<br>    5. body-parser<br><strong>自定义模块</strong><br>    1. node环境下每创建一个js都相当于创建一个新的模块。每个模块中的方法都是该模块私有的方法，不同模块间即使同名的方法也不会冲突。<br>    2. module.exports就是node天生自带的用来导出模块中方法的方法。<br>    3. ruquire是NODE中内置导入模块的方法<br>    4. require导入模块是同步的，每一次导入模块都是把要导入的js文件自上而下执行一遍（执行一遍）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> // 属性和方法  暴露在外面被调用的方法</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">let module = require(&apos;./xx&apos;);</span><br><span class="line">// 1.可以省略.js;</span><br><span class="line">// 2. 调取自定义模块需要加 ../(上级目录) ./(当前目录)  /(根目录)  </span><br><span class="line">// 3. 不加默认逐步产找第三方》内置》报错</span><br></pre></td></tr></table></figure><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>构建服务器express</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let express = require(&apos;express&apos;),</span><br><span class="line">app = express();</span><br><span class="line">app.listen(8080, () =&gt; &#123;</span><br><span class="line">console.log(&apos;server is create success！listening on 8080 port！&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(express.static(&apos;./static&apos;));</span><br><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">res.status(404);</span><br><span class="line">res.send(&apos;NOT FOUND!&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>构建服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">let http = require(&apos;http&apos;),</span><br><span class="line">url = require(&apos;url&apos;),</span><br><span class="line">path = require(&apos;path&apos;);</span><br><span class="line">let &#123;</span><br><span class="line">readFile</span><br><span class="line">&#125; = require(&apos;./utils/promiseFS&apos;);</span><br><span class="line"></span><br><span class="line">//=&gt;HTTP.CREATE-SERVER创建服务</span><br><span class="line">let server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">let &#123;</span><br><span class="line">//=&gt;URL存储的是请求信息中的：资源文件的路径名称和问号传参的信息</span><br><span class="line">url: requestURL</span><br><span class="line">&#125; = req;</span><br><span class="line">let &#123;</span><br><span class="line">//=&gt;请求资源的路径名称</span><br><span class="line">pathname,</span><br><span class="line">//=&gt;问号传参信息(键值对)</span><br><span class="line">query</span><br><span class="line">&#125; = url.parse(requestURL, true);</span><br><span class="line"></span><br><span class="line">//=&gt;根据请求的路径和名称，让其去STATIC文件中查找对应的资源文件内容</span><br><span class="line">pathname = path.resolve(&apos;./static&apos;) + pathname;</span><br><span class="line">readFile(pathname).then(result =&gt; &#123;</span><br><span class="line">//=&gt;返回的数据格式一般都是字符串或者BUFFER  </span><br><span class="line">//WRITE服务器返回信息（可以执行多次）</span><br><span class="line">//END告诉客户端返回的信息已经结束了（必须写的）</span><br><span class="line">//RES.END相当于基于响应主体返回信息，还需要掌握基于响应头返回信息RES.WRITE-HEAD(STATUS,OPTIONS)</span><br><span class="line">res.writeHead(200, &#123;</span><br><span class="line">//=&gt;告诉客户端返回的数据格式和编码方式：返回的格式类型是MIME类型（每一种文件都有一个自己所属的类型，而这个类型就是MIME类型）</span><br><span class="line">&apos;content-type&apos;: &apos;text/css&apos;</span><br><span class="line">&#125;);</span><br><span class="line">res.end(result);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">res.end(&apos;not found!&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//=&gt;SERVER.LISTEN监听端口号</span><br><span class="line">server.listen(8080, () =&gt; &#123;</span><br><span class="line">console.log(&apos;server is create success！listening on 8080 port！&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>promiseFs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;),</span><br><span class="line">path = require(&apos;path&apos;),</span><br><span class="line">exportsOBJ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">//=&gt;根据后缀名返回编码格式:UTF8/NULL</span><br><span class="line">function suffixHandle(pathname) &#123;</span><br><span class="line">let suffixREG = /\.([0-9a-zA-Z]+)$/,</span><br><span class="line">suffix = suffixREG.test(pathname) ? suffixREG.exec(pathname)[1] : &apos;&apos;,</span><br><span class="line">encoding = &apos;utf8&apos;;</span><br><span class="line">/^(PNG|GIF|JPG|JPEG|WEBP|BMP|ICO|SVG|MP3|MP4|WAV|OGG|M3U8)$/i.test(suffix) ? encoding = null : null;</span><br><span class="line">return encoding;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//=&gt;READ-FILE/READ-DIR/MK-DIR/RM-DIR/UN-LINK</span><br><span class="line">[&apos;readFile&apos;, &apos;readdir&apos;, &apos;mkdir&apos;, &apos;rmdir&apos;, &apos;unlink&apos;].forEach(item =&gt; &#123;</span><br><span class="line">exportsOBJ[item] = function anonymous(pathname) &#123;</span><br><span class="line">pathname = path.resolve(pathname);</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">let encoding = suffixHandle(pathname),</span><br><span class="line">callback = (err, result) =&gt; &#123;</span><br><span class="line">if (err !== null) &#123;</span><br><span class="line">reject(err);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">resolve(result);</span><br><span class="line">&#125;;</span><br><span class="line">if (item !== &apos;readFile&apos;) &#123;</span><br><span class="line">encoding = callback;</span><br><span class="line">callback = null;</span><br><span class="line">&#125;</span><br><span class="line">fs[item](pathname, encoding, callback);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//=&gt;WRITE-FILE / APPEND-FILE</span><br><span class="line">[&apos;writeFile&apos;, &apos;appendFile&apos;].forEach(item =&gt; &#123;</span><br><span class="line">exportsOBJ[item] = function anonymous(pathname, content) &#123;</span><br><span class="line">pathname = path.resolve(pathname);</span><br><span class="line">//=&gt;如果是JSON对象,我们转化为JSON字符串</span><br><span class="line">content !== null &amp;&amp; typeof content === &apos;object&apos; ? content = JSON.stringify(content) : null;</span><br><span class="line">typeof content !== &apos;string&apos; ? content += &apos;&apos; : null;</span><br><span class="line"></span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">let encoding = suffixHandle(pathname),</span><br><span class="line">callback = (err, result) =&gt; &#123;</span><br><span class="line">if (err !== null) &#123;</span><br><span class="line">reject(err);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">resolve(result);</span><br><span class="line">&#125;;</span><br><span class="line">fs[item](pathname, content, encoding, callback);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//=&gt;COPY-FILE</span><br><span class="line">exportsOBJ[&apos;copyFile&apos;] = function anonymous(pathname1, pathname2) &#123;</span><br><span class="line">pathname1 = path.resolve(pathname1);</span><br><span class="line">pathname2 = path.resolve(pathname2);</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">fs[&apos;copyFile&apos;](pathname1, pathname2, err =&gt; &#123;</span><br><span class="line">if (err !== null) &#123;</span><br><span class="line">reject(err);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">resolve();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">function readFile(pathname) &#123;</span><br><span class="line">//=&gt;富媒体资源在获取内容的时候不能使用UTF8编码格式</span><br><span class="line">//获取文件的后缀名</span><br><span class="line">let suffixREG = /\.([0-9a-zA-Z]+)$/,</span><br><span class="line">suffix = suffixREG.test(pathname) ? suffixREG.exec(pathname)[1] : &apos;&apos;,</span><br><span class="line">encoding = &apos;utf8&apos;;</span><br><span class="line">/^(PNG|GIF|JPG|JPEG|WEBP|BMP|ICO|SVG|MP3|MP4|WAV|OGG|M3U8)$/i.test(suffix) ? encoding = null : null;</span><br><span class="line">//=&gt;用户调用的时候，传递的PATH-NAME都以项目根目录作为参照（执行JS也是在根目录执行），用户只需要把读取文件，相对根目录的路径和名称传递进来即可 =&gt;获取的是绝对路径</span><br><span class="line">pathname = path.resolve(pathname);</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">fs.readFile(pathname, encoding, (err, result) =&gt; &#123;</span><br><span class="line">if (err !== null) &#123;</span><br><span class="line">reject(err);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">resolve(result);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125; */</span><br><span class="line"></span><br><span class="line">module.exports = exportsOBJ;</span><br></pre></td></tr></table></figure><p>压缩</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 读取CSS目录中所有的文件，找到后缀名是.CSS的</span><br><span class="line"> * 依次读取CSS文件中的内容，最后把所有内容合并在一起</span><br><span class="line"> * 把合并后的结果放到DIST文件夹的index.css文件中 </span><br><span class="line"> */</span><br><span class="line">let &#123;</span><br><span class="line">readdir,</span><br><span class="line">readFile,</span><br><span class="line">writeFile</span><br><span class="line">&#125; = require(&apos;./utils/promiseFS&apos;);</span><br><span class="line">let less = require(&apos;less&apos;);</span><br><span class="line"></span><br><span class="line">readdir(&apos;./css&apos;).then(result =&gt; &#123;</span><br><span class="line">result = result.filter(item =&gt; /\.CSS$/i.test(item));</span><br><span class="line">result = result.map(item =&gt; &#123;</span><br><span class="line">return readFile(`./css/$&#123;item&#125;`);</span><br><span class="line">&#125;);</span><br><span class="line">return Promise.all(result);</span><br><span class="line">&#125;).then(results =&gt; &#123;</span><br><span class="line">results = results.join(&apos;&apos;);</span><br><span class="line">//=&gt;此时的RESULTS存储的是未经过压缩的合并后的CSS代码，接下来基于LESS模块完成CSS内容的压缩</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">less.render(results, &#123;</span><br><span class="line">//=&gt;LESS模块规定：设置压缩的方式</span><br><span class="line">compress: true</span><br><span class="line">&#125;, (err, result) =&gt; &#123;</span><br><span class="line">if (err !== null) reject(err);</span><br><span class="line">//=&gt;RESULT是一个对象，对象的CSS属性包含压缩后的代码</span><br><span class="line">resolve(result.css);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;).then(css =&gt; &#123;</span><br><span class="line">//=&gt;把压缩后的写在指定的目录中</span><br><span class="line">return writeFile(&apos;./dist/index.css&apos;, css);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript——node&quot;&gt;&lt;a href=&quot;#JavaScript——node&quot; class=&quot;headerlink&quot; title=&quot;JavaScript——node&quot;&gt;&lt;/a&gt;JavaScript——node&lt;/h2&gt;&lt;h3 id=&quot;node&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="node" scheme="https://wangyiye.github.io/categories/node/"/>
    
    
      <category term="js" scheme="https://wangyiye.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>HTTP1.0 HTTP 1.1 HTTP 2.0主要区别 （转载）</title>
    <link href="https://wangyiye.github.io/2019/09/14/HTTP1-0-HTTP-1-1-HTTP-2-0%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/"/>
    <id>https://wangyiye.github.io/2019/09/14/HTTP1-0-HTTP-1-1-HTTP-2-0主要区别/</id>
    <published>2019-09-14T00:23:44.000Z</published>
    <updated>2019-09-14T00:28:26.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP1-0-HTTP-1-1主要区别"><a href="#HTTP1-0-HTTP-1-1主要区别" class="headerlink" title="HTTP1.0 HTTP 1.1主要区别"></a>HTTP1.0 HTTP 1.1主要区别</h3><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><p>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。</p><p>HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。</p><h4 id="节约带宽"><a href="#节约带宽" class="headerlink" title="节约带宽"></a>节约带宽</h4><p>HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。</p><p>这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。</p><p>另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。</p><h4 id="HOST域"><a href="#HOST域" class="headerlink" title="HOST域"></a>HOST域</h4><p>现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。</p><p>HTTP1.0是没有host域的，HTTP1.1才支持这个参数。</p><h3 id="HTTP1-1-HTTP-2-0主要区别"><a href="#HTTP1-1-HTTP-2-0主要区别" class="headerlink" title="HTTP1.1 HTTP 2.0主要区别"></a>HTTP1.1 HTTP 2.0主要区别</h3><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p><p>当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p><p>TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。</p><p>关于多路复用，可以参看学习NIO 。</p><h4 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h4><p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p><h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>意思是说，当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。</p><p>服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。</p><p>详细内容：</p><p>1、HTTP/2.0 相比1.0有哪些重大改进？ <a href="https://www.zhihu.com/question/34074946" target="_blank" rel="noopener">https://www.zhihu.com/question/34074946</a><br>2、深入研究：HTTP2 的真正性能到底如何  <a href="https://segmentfault.com/a/1190000007219256" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007219256</a><br>————————————————<br>版权声明：本文为CSDN博主「Sam哥哥」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/linsongbin1/article/details/54980801" target="_blank" rel="noopener">https://blog.csdn.net/linsongbin1/article/details/54980801</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTTP1-0-HTTP-1-1主要区别&quot;&gt;&lt;a href=&quot;#HTTP1-0-HTTP-1-1主要区别&quot; class=&quot;headerlink&quot; title=&quot;HTTP1.0 HTTP 1.1主要区别&quot;&gt;&lt;/a&gt;HTTP1.0 HTTP 1.1主要区别&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript What’s new in ES2019</title>
    <link href="https://wangyiye.github.io/2019/09/10/ES2019/"/>
    <id>https://wangyiye.github.io/2019/09/10/ES2019/</id>
    <published>2019-09-10T10:51:32.000Z</published>
    <updated>2019-09-10T10:51:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-What’s-new-in-ES2019"><a href="#JavaScript-What’s-new-in-ES2019" class="headerlink" title="JavaScript What’s new in ES2019"></a>JavaScript What’s new in ES2019</h2><p><img src="/2019/09/10/ES2019/1.png" alt="Alt text"></p><h3 id="Array-flat"><a href="#Array-flat" class="headerlink" title="Array.flat()"></a>Array.flat()</h3><p>现在可以递归地将嵌套数组扁平化到指定的深度。默认值是1，如果你想完全深入使用无穷大。该方法不修改原始数组，而是创建一个新的数组:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [1, 2, [3, 4]];</span><br><span class="line">arr1.flat(); // [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">const arr2 = [1, 2, [3, 4, [5, 6]]];</span><br><span class="line">arr2.flat(2); // [1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">const arr3 = [1, 2, [3, 4, [5, 6, [7, 8]]]];</span><br><span class="line">arr3.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure><p>如果你的数组中有一个空槽，它将被删除:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr4 = [1, 2, , 4, 5];</span><br><span class="line">arr4.flat(); // [1, 2, 4, 5]</span><br></pre></td></tr></table></figure><h3 id="Array-flatMap"><a href="#Array-flatMap" class="headerlink" title="Array.flatMap()"></a>Array.flatMap()</h3><p>一个新的方法，结合了基本的map函数，然后使用新的Array.flat()方法将结果扁平化到1的深度:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">arr1.map(x =&gt; [x * 4]); // [[4], [8], [12]]</span><br><span class="line">arr1.flatMap(x =&gt; [x * 4]); // [4, 8, 12]</span><br></pre></td></tr></table></figure><p>另一个更有用的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const sentence = [&quot;This is a&quot;, &quot;regular&quot;, &quot;sentence&quot;];</span><br><span class="line"></span><br><span class="line">sentence.map(x =&gt; x.split(&quot; &quot;)); // [[&quot;This&quot;,&quot;is&quot;,&quot;a&quot;],[&quot;regular&quot;],[&quot;sentence&quot;]]</span><br><span class="line">sentence.flatMap(x =&gt; x.split(&quot; &quot;)); // [&quot;This&quot;,&quot;is&quot;,&quot;a&quot;,&quot;regular&quot;, &quot;sentence&quot;]</span><br></pre></td></tr></table></figure><h3 id="String-trimStart-and-String-trimEnd"><a href="#String-trimStart-and-String-trimEnd" class="headerlink" title="String.trimStart() and String.trimEnd()"></a>String.trimStart() and String.trimEnd()</h3><p>除了string . trim()删除字符串两边的空格外，现在还有单独的方法只删除字符串两边的空格:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const test = &quot; hello &quot;;</span><br><span class="line"></span><br><span class="line">test.trim(); // &quot;hello&quot;;</span><br><span class="line">test.trimStart(); // &quot;hello &quot;;</span><br><span class="line">test.trimEnd(); // &quot; hello&quot;;</span><br></pre></td></tr></table></figure><h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h3><p>将键值对列表转换为对象的新方法。它执行与已经熟悉的函数对象相反的操作。将对象转换为数组时使用的项，以便更容易地进行操作。在转换之后，您将得到一个数组，但是现在您可以将操作后的数组返回到一个对象中。让我们试着用一个例子，我们想平方所有对象属性的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; prop1: 2, prop2: 10, prop3: 15 &#125;;</span><br><span class="line"></span><br><span class="line">let array = Object.entries(obj); // [[&quot;prop1&quot;, 2], [&quot;prop2&quot;, 10], [&quot;prop3&quot;, 15]]</span><br></pre></td></tr></table></figure><p>让我们用一个简单的映射将键值对的新列表的值平方:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array = array.map(([key, value]) =&gt; [key, Math.pow(value, 2)]); // [[&quot;prop1&quot;, 4], [&quot;prop2&quot;, 100], [&quot;prop3&quot;, 225]]</span><br></pre></td></tr></table></figure><p>我们已经转换了对象值，但我们只剩下一个数组，这就是object . fromentries的作用，它将数组转换回一个对象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const newObj = Object.fromEntries(array); // &#123;prop1: 4, prop2: 100, prop3: 225&#125;</span><br></pre></td></tr></table></figure><h3 id="Optional-Catch-Binding"><a href="#Optional-Catch-Binding" class="headerlink" title="Optional Catch Binding"></a>Optional Catch Binding</h3><p>新提案允许您完全省略catch()参数，因为在很多情况下，您不希望使用它:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125; catch (er) &#123;</span><br><span class="line">  //handle error with parameter er</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">  //handle error without parameter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Symbol-description"><a href="#Symbol-description" class="headerlink" title="Symbol.description"></a>Symbol.description</h3><p>您现在可以访问符号的description属性，而不是使用toString()方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const testSymbol = Symbol(&quot;Desc&quot;);</span><br><span class="line"></span><br><span class="line">testSymbol.description; // &quot;Desc&quot;</span><br></pre></td></tr></table></figure><h3 id="Function-toString"><a href="#Function-toString" class="headerlink" title="Function.toString()"></a>Function.toString()</h3><p>现在，对函数调用toString()将返回函数的定义，包括空格和注释。之前我们有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function /* foo comment */ foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">foo.toString(); // &quot;function foo() &#123;&#125;&quot;</span><br></pre></td></tr></table></figure><p>And now it’s:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo.toString(); // &quot;function /* foo comment */ foo() &#123;&#125;&quot;</span><br></pre></td></tr></table></figure><h3 id="JSON-parse-的改进"><a href="#JSON-parse-的改进" class="headerlink" title="JSON.parse()的改进"></a>JSON.parse()的改进</h3><p>行分隔符(\u2028)和段落分隔符(\u2029)符号现在可以正确解析，而不会导致SyntaxError。</p><p>翻译自 <a href="https://blog.tildeloop.com/posts/javascript-what%E2%80%99s-new-in-es2019" target="_blank" rel="noopener">https://blog.tildeloop.com/posts/javascript-what%E2%80%99s-new-in-es2019</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript-What’s-new-in-ES2019&quot;&gt;&lt;a href=&quot;#JavaScript-What’s-new-in-ES2019&quot; class=&quot;headerlink&quot; title=&quot;JavaScript What’s new in ES201
      
    
    </summary>
    
    
      <category term="前端" scheme="https://wangyiye.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="指令" scheme="https://wangyiye.github.io/tags/%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染的重排与重绘以及前端性能优化</title>
    <link href="https://wangyiye.github.io/2019/09/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E7%9A%84%E9%87%8D%E6%8E%92%E4%B8%8E%E9%87%8D%E7%BB%98%E4%BB%A5%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://wangyiye.github.io/2019/09/09/浏览器渲染的重排与重绘以及性能优化/</id>
    <published>2019-09-09T15:51:32.000Z</published>
    <updated>2019-09-09T16:51:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="细说浏览器渲染的重排与重绘"><a href="#细说浏览器渲染的重排与重绘" class="headerlink" title="细说浏览器渲染的重排与重绘"></a>细说浏览器渲染的重排与重绘</h2><blockquote><p>前端性能优化因为涉及到计算机网络、数据算法、图形图像处理、浏览器渲染等多方面计算机知识，常作为前端工程师乐此不疲的技术讨论话题，也正因如此，它也是面试时容易被问及的面试题之一。</p></blockquote><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul><li><p>URL从输入到页面展示的过程</p></li><li><p>DOM和JavaScript的关系</p></li><li><p>为什么操作DOM会很“慢”</p></li><li><p>浏览器解析HTML的过程</p></li><li><p>重排</p></li><li><p>重绘</p></li><li><p>优化方案</p></li></ul><h3 id="URL从输入到页面展示的过程"><a href="#URL从输入到页面展示的过程" class="headerlink" title="URL从输入到页面展示的过程"></a>URL从输入到页面展示的过程</h3><pre><code>在探讨浏览器解析html之前，先了解url从输入到最后页面渲染的过程是一个很有必要的步骤，它可以帮助我们把握整体流程，让我们在了解HTML解析细节之前知道它处于整个请求周期中的哪一阶段，这对我们构建完善知识图谱很有帮助。</code></pre><p>首先，我们假设输入的url的请求为最简单的Http请求，以GET请求为例，大致分以下几个步骤：</p><h5 id="1-用户在浏览器的地址栏输入访问的URL地址。浏览器会先根据这个URL查看浏览器缓存-系统缓存-路由器缓存，若缓存中有，直接跳到第6步操作，若没有，则按照下面的步骤进行操作。"><a href="#1-用户在浏览器的地址栏输入访问的URL地址。浏览器会先根据这个URL查看浏览器缓存-系统缓存-路由器缓存，若缓存中有，直接跳到第6步操作，若没有，则按照下面的步骤进行操作。" class="headerlink" title="1. 用户在浏览器的地址栏输入访问的URL地址。浏览器会先根据这个URL查看浏览器缓存-系统缓存-路由器缓存，若缓存中有，直接跳到第6步操作，若没有，则按照下面的步骤进行操作。"></a>1. 用户在浏览器的地址栏输入访问的URL地址。浏览器会先根据这个URL查看浏览器缓存-系统缓存-路由器缓存，若缓存中有，直接跳到第6步操作，若没有，则按照下面的步骤进行操作。</h5><h5 id="2-浏览器根据输入的URL地址解析出主机名。"><a href="#2-浏览器根据输入的URL地址解析出主机名。" class="headerlink" title="2. 浏览器根据输入的URL地址解析出主机名。"></a>2. 浏览器根据输入的URL地址解析出主机名。</h5><pre><code>&gt;  URI（Uniform Resource Identifier / 统一资源标志符）  包含url和urnURL（Uniform Resource Locator / 统一资源定位符）URN（Uniform Resource Name / 统一资源名称）国际统一发版编号（使用率极低）URL    https://mbd.baidu.com:80/newspage/data/landingsuper?context=%7B&quot;nid&quot;%3A&quot;news_9461431018812454469&quot;%7D&amp;n_type=0&amp;p_from=1#ee23</code></pre><ul><li>协议 http://    <ul><li>能够把客户端和服务器端通信的信息进行传输的工具<ul><li>HTTP 超文本传输协议</li><li>HTTPS 为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密</li><li>FTP 文件传输协议（应用于资源的下载和上传）</li></ul></li></ul></li><li>域名：mbd.baidu.com：一个让用户方便记忆的名称（不通过域名，直接用服务器的外网ip）（.com /.cn/.com.cn/.edu/.io/.gov/.org/.net<ul><li>顶级域名 baidu.com</li><li><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 1级域名</li><li>music.baidu.com 2级域名</li><li>kbs.music..baidu.com 3级域名</li></ul></li><li>端口号：  :80  (0-65535) <ul><li>用端口号区分同一台服务器上不同的项目,如果项目采用的就是默认端口号，书写地址可以不用加端口号，浏览器再发送请求的时候会默认添加端口号。<ul><li>http 80</li><li>https 443</li><li>ftp 21</li></ul></li></ul></li><li>请求资源路径名称：/newspage/data/landingsuper<ul><li>默认路径或名称  xxx.com/ 没写路径的话找默认资源，可以在服务器自己配置一般默认资源名称default.html </li><li>伪URL地址处理（URL重写为了增加seo搜索引擎优化，动态的网址一般不会被搜索引擎收录，所以我们把动态的网址静态化，需要重写url</li></ul></li><li>问号传参信息:  ?context=%7B”nid”%3A”news_9461431018812454469”%7D&amp;n_type=0&amp;p_from=1<ul><li>客户端把信息传递给服务器方式<ul><li>url地址问号传参</li><li>请求报文传输</li></ul></li><li>实现不同页面之间的信息交互 列表到详情</li></ul></li><li>HASH值 #ee23<ul><li>信息传输</li><li>锚点定位</li><li>基于HASH实现路由管控，不同的HASH值展示不同的组件和模块。</li></ul></li></ul><p>请求的地址中如果出现UNICODE编码内容，现代版浏览器会默认的进行编码<br>    1. 基于encodeURI编码，我们可以基于decodeURI解码，编码的是整个URL，这样整个URL中的特殊字符都会自动编译，<br>    2. encodeURIComponent/decodeURIComponent,是对URL的部分信息编码，一般是？后的信息编码。客户端和服务器端进行信息传输的时候，如果需要把请求的信息编码，要基于这两种赋值，进行统一编码解码。<br>    3. 客户端还存在针对中文的编码方式escape/unescape  后台不一定有，一般应用于客户端页面之间自己的处理。例如从列表跳转到详情，可以把传递的中文信息基于这个编码，详情页面获取编码后的信息再解码。各种客户端中的cookie信息，如果信息是中文，我们也基于这种办法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> //=&gt;基于JS实现页面跳转</span><br><span class="line">link.onclick = function () &#123;</span><br><span class="line">//=&gt;获取当前页面的URL地址</span><br><span class="line">let url = window.location.href;</span><br><span class="line">//=&gt;跳转页面</span><br><span class="line">window.location.href = &quot;http://www.zhufengpeixun.cn/stu/?from=&quot; + encodeURIComponent(url);</span><br><span class="line">// window.open(&quot;http://www.zhufengpeixun.cn/&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-浏览器将主机名转换成服务器ip地址。浏览器先查找本地DNS缓存列表，看缓存里面是否存在这个ip-如果有则进入第4步，如果缓存中不存在这个ip地址，就再向浏览器默认的DNS服务器发送查询请求，同时缓存当前这个ip到DNS缓存列表中。更详细步骤参考https-www-cnblogs-com-xsilence-p-6035559-html"><a href="#3-浏览器将主机名转换成服务器ip地址。浏览器先查找本地DNS缓存列表，看缓存里面是否存在这个ip-如果有则进入第4步，如果缓存中不存在这个ip地址，就再向浏览器默认的DNS服务器发送查询请求，同时缓存当前这个ip到DNS缓存列表中。更详细步骤参考https-www-cnblogs-com-xsilence-p-6035559-html" class="headerlink" title="3. 浏览器将主机名转换成服务器ip地址。浏览器先查找本地DNS缓存列表，看缓存里面是否存在这个ip,如果有则进入第4步，如果缓存中不存在这个ip地址，就再向浏览器默认的DNS服务器发送查询请求，同时缓存当前这个ip到DNS缓存列表中。更详细步骤参考https://www.cnblogs.com/xsilence/p/6035559.html"></a>3. 浏览器将主机名转换成服务器ip地址。浏览器先查找本地DNS缓存列表，看缓存里面是否存在这个ip,如果有则进入第4步，如果缓存中不存在这个ip地址，就再向浏览器默认的DNS服务器发送查询请求，同时缓存当前这个ip到DNS缓存列表中。更详细步骤参考<a href="https://www.cnblogs.com/xsilence/p/6035559.html" target="_blank" rel="noopener">https://www.cnblogs.com/xsilence/p/6035559.html</a></h5><blockquote><p>在服务器上存储着  域名 –服务器外网IP ,对DNS发送请求，进行DNS解析过程即：根据域名，在DNS服务器上查找到对应服务器的外网IP</p></blockquote><p>DNS优化</p><ul><li>缓存 浏览器会在第一次解析后，默认建立缓存，时间为1min</li><li>减少DNS解析次数，一个网站中我们需要发送请求的域名和服务器尽可能减少</li><li>DNS预获取，dns-prefetch: 在页面加载开始的时候，就把当前页面中需要访问其他域名（服务器）的信息进行提前dns解析，以后加载到具体内容部分可以不用解析。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//static.360buyimg.com&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//misc.360buyimg.com&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img10.360buyimg.com&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img11.360buyimg.com&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img12.360buyimg.com&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-拿到ip地址后，浏览器再从URL中解析出端口号。"><a href="#4-拿到ip地址后，浏览器再从URL中解析出端口号。" class="headerlink" title="4. 拿到ip地址后，浏览器再从URL中解析出端口号。"></a>4. 拿到ip地址后，浏览器再从URL中解析出端口号。</h5><h5 id="5-拿到ip和端口后，浏览器会建立一条与目标Web服务器的TCP连接，也就是传说中的三次握手。"><a href="#5-拿到ip和端口后，浏览器会建立一条与目标Web服务器的TCP连接，也就是传说中的三次握手。" class="headerlink" title="5. 拿到ip和端口后，浏览器会建立一条与目标Web服务器的TCP连接，也就是传说中的三次握手。"></a>5. 拿到ip和端口后，浏览器会建立一条与目标Web服务器的TCP连接，也就是传说中的三次握手。</h5><p><img src="/2019/09/09/浏览器渲染的重排与重绘以及性能优化/3.png" alt="Image text"></p><ul><li>第一次握手：由浏览器发起，告诉服务器我要发送请求了</li><li>第二次握手：由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧</li><li>第三次握手：由浏览器发送，告诉服务器，我马上就发了，准备接受吧</li></ul><h5 id="6-浏览器向服务器发送一条HTTP请求报文。"><a href="#6-浏览器向服务器发送一条HTTP请求报文。" class="headerlink" title="6. 浏览器向服务器发送一条HTTP请求报文。"></a>6. 浏览器向服务器发送一条HTTP请求报文。</h5><h5 id="7-服务器向浏览器返回一条HTTP响应报文。"><a href="#7-服务器向浏览器返回一条HTTP响应报文。" class="headerlink" title="7. 服务器向浏览器返回一条HTTP响应报文。"></a>7. 服务器向浏览器返回一条HTTP响应报文。</h5><ul><li><p>HTTP报文：请求报文+响应报文</p></li><li><p>请求报文 ：所有经过传输协议，客户端传递给服务器的内容<br><img src="/2019/09/09/浏览器渲染的重排与重绘以及性能优化/1.png" alt="Image text"></p><ul><li>起始行</li><li>请求首部</li><li>请求主体<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>响应报文：所有经过传输协议，服务器返回给客户端的内容<br><img src="/2019/09/09/浏览器渲染的重排与重绘以及性能优化/2.png" alt="Image"></p><ul><li><p>HTTP状态码的信息</p></li><li><p>响应首部</p></li><li><p>响应主体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;version&gt;&lt;status&gt;&lt;reason-phrase&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure><p>HTTP状态码</p><blockquote><p>1-5开头三位数字</p></blockquote></li><li><p>200 OK</p></li><li><p>201 created一般应用于告诉服务器创建一个新文件，服务器创建成功后返回的状态码</p></li><li><p>204 NO Content 对于某些请求 put delete 请求，服务器拒绝请求，返回空内容，并且以状态码204告知。</p></li><li><p>301 Moved Permanently  永久重定向（永久转移） </p></li><li><p>302 Moved Temporarily  临时转移，现在用307处理，临时重定向Temporary Redirect  主要应用于负载均衡。</p></li><li><p>304 NOT Modified 设置HTTP的协商缓存 </p></li><li><p>400 Bad Request    传递给服务器的 参数错误</p></li><li><p>401 Unauthorized  无权限访问</p></li><li><p>404 Not Found  请求地址错误</p></li><li><p>500  Internal Server Error未知服务器错误</p></li><li><p>503 Service Unavailable 服务器超负荷</p></li></ul></li></ul><h5 id="8-关闭连接-浏览器解析文档。"><a href="#8-关闭连接-浏览器解析文档。" class="headerlink" title="8.关闭连接 浏览器解析文档。"></a>8.关闭连接 浏览器解析文档。</h5><p><img src="/2019/09/09/浏览器渲染的重排与重绘以及性能优化/5.png" alt="Image text"></p><ul><li>第一次挥手：由浏览器发起，发送给服务器，我请求报文发送完了，你准备关闭吧；</li><li>第二次挥手：由服务器发起，告诉浏览器，我接收完请求报文，我准备关闭，你也准备吧；</li><li>第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完毕，你准备关闭吧；</li><li>第四次挥手：由浏览器发起，告诉服务器，我响应报文接收完毕，我准备关闭，你也准备吧；</li></ul><h5 id="9-如果文档中还有资源则重复6、7、8动作，直至资源全部加载完毕。-优化（A：Connection-Keep-Alive-保持TCP不中断）"><a href="#9-如果文档中还有资源则重复6、7、8动作，直至资源全部加载完毕。-优化（A：Connection-Keep-Alive-保持TCP不中断）" class="headerlink" title="9. 如果文档中还有资源则重复6、7、8动作，直至资源全部加载完毕。 优化（A：Connection: Keep-Alive 保持TCP不中断）"></a>9. 如果文档中还有资源则重复6、7、8动作，直至资源全部加载完毕。 优化（A：Connection: Keep-Alive 保持TCP不中断）</h5><h3 id="DOM和JavaScript的关系"><a href="#DOM和JavaScript的关系" class="headerlink" title="DOM和JavaScript的关系"></a>DOM和JavaScript的关系</h3><p>文档对象模型（DOM）是一个独立于语言，用于操作XML和HTML文档的API,在web端，我们常用来操作HTML，但其实DOM也是可以操作XML文档的。</p><p>我们现在知道，DOM是一个独立于语言的API，换句话说，DOM是一个与语言无关的API，别的语言也可以实现操作DOM的具体api，但是它在浏览器中是用JavaScript来实现的，也因此，DOM是现在JavaScript编码中很重要的一部分，因为JavaScript很多时候都在操作底层文档。</p><h3 id="为什么操作DOM会很慢"><a href="#为什么操作DOM会很慢" class="headerlink" title="为什么操作DOM会很慢"></a>为什么操作DOM会很慢</h3><p>虽然DOM是由JavaScript实现的，但是在浏览器中都是把DOM和JavaScript分开来实现的，比如IE中，JavaScript的实现名为JScript，放在jscript.dll文件中，而DOM则放在另一个叫做mshtml.dll的库中。在Safari中，DOM和渲染是使用Webkit中的WebCore实现，而JavaScript是由独立的JavaScriptCore引擎实现，同样在Chrome中，同样是使用WebCore来实现渲染，而JavaScript引擎则是他们自己研发的V8引擎。</p><p>由于DOM和JavaScript是被分开独立实现的，因此，每一次在通过js操作DOM的时候，就需要先去连接js和DOM，我们可以这样理解：把DOM和JavaScript比作两个岛，他们之间通过一个收费的桥连接着，每一次访问DOM的时候，就需要经过这座桥，并且给“过路费”，访问的次数越多，路费就会越高，并且访问到DOM后，操作具体的DOM还需要给“操作费”，由于浏览器访问DOM的操作很多，因此，“路费”和“操作费”自然会增加，这就是为什么操作DOM会很慢的原因</p><h3 id="浏览器渲染HTML的步骤"><a href="#浏览器渲染HTML的步骤" class="headerlink" title="浏览器渲染HTML的步骤"></a>浏览器渲染HTML的步骤</h3><p><img src="/2019/09/09/浏览器渲染的重排与重绘以及性能优化/4.png" alt="Image text"></p><p>HTML渲染大致分为如下几步：</p><ol><li><p>HTML被HTML解析器解析成DOM Tree, css则被css解析器解析成CSSOM Tree。</p></li><li><p>DOM Tree和CSSOM Tree解析完成后，被附加到一起，形成渲染树（Render Tree）。</p></li><li><p>节点信息计算(重排)，这个过程被叫做Layout(Webkit)或者Reflow(Mozilla)。即根据渲染树计算每个节点的几何信息(计算它们在设备视口(viewport)内的确切位置和大小)。</p></li><li><p>渲染绘制(重绘)，这个过程被叫做(Painting 或者 Repaint)。即根据计算好的信息绘制整个页面(得到节点的绝对像素)。</p></li><li><p>Display:将像素发送给GPU，展示在页面上</p></li></ol><p>以上5步简述浏览器的一次渲染过程，理论上，每一次的dom更改或者css几何属性更改，都会引起一次浏览器的重排/重绘过程，而如果是css的非几何属性更改，则只会引起重绘过程。所以说重排一定会引起重绘，而重绘不一定会引起重排。</p><h3 id="重排（Relayout-Reflow）"><a href="#重排（Relayout-Reflow）" class="headerlink" title="重排（Relayout/Reflow）"></a>重排（Relayout/Reflow）</h3><p>在弄明白什么是重排之前，我们要知道：浏览器渲染页面默认采用的是流式布局模型（Flow Based Layout），这一点很重要。</p><p>所谓重排，实际上是根据渲染树中每个渲染对象的信息，计算出各自渲染对象的几何信息（DOM对象的位置和尺寸大小），并将其安置在界面中的正确位置。</p><p>由于浏览器渲染界面是基于流式布局模型的，也就是某一个DOM节点信息更改了，就需要对DOM结构进行重新计算，重新布局界面，再次引发回流，只是这个结构更改程度会决定周边DOM更改范围，即全局范围和局部范围，全局范围就是从根节点html开始对整个渲染树进行重新布局，例如当我们改变了窗口尺寸或方向或者是修改了根元素的尺寸或者字体大小等；而局部布局可以是对渲染树的某部分或某一个渲染对象进行重新布局。</p><h4 id="在此，总结会引起重排的操作有："><a href="#在此，总结会引起重排的操作有：" class="headerlink" title="在此，总结会引起重排的操作有："></a>在此，总结会引起重排的操作有：</h4><ol><li><p>页面首次渲染。</p></li><li><p>浏览器窗口大小发生改变。</p></li><li><p>元素尺寸或位置发生改变。</p></li><li><p>元素内容变化（文字数量或图片大小等等）。</p></li><li><p>元素字体大小变化。</p></li><li><p>添加或者删除可见的DOM元素。</p></li><li><p>激活CSS伪类（例如：:hover）。</p></li><li><p>设置style属性</p></li><li><p>查询某些属性或调用某些方法。</p></li></ol><blockquote><p>常见引起重排属性和方法<br>width    height    margin    padding<br>display    border    position    overflow<br>clientWidth    clientHeight    clientTop    clientLeft<br>offsetWidth    offsetHeight    offsetTop    offsetLeft<br>scrollWidth    scrollHeight    scrollTop    scrollLeft<br>scrollIntoView()    scrollTo()    getComputedStyle()<br>getBoundingClientRect()    scrollIntoViewIfNeeded()</p></blockquote><blockquote><p>重排也叫回流，实际上，reflow的字面意思也是回流，之所以有的叫做重排，也许是因为重排更好理解，更符合中国人的思维。标准文档之所以叫做回流（Reflow）,是因为浏览器渲染是基于“流式布局”的模型，流实际就使我们常说的文档流，当dom或者css几何属性发生改变的时候，文档流会受到波动联动的去更改，流就好比一条河里的水，回流就好比向河里扔了一块石头，激起涟漪，然后引起周边水流受到波及，所以叫做回流，这样理解似乎更标准更规范，不过叫什么并不重要，重要的是我们真正理解了这个过程便好。</p></blockquote><h3 id="重绘（Repainting）"><a href="#重绘（Repainting）" class="headerlink" title="重绘（Repainting）"></a>重绘（Repainting）</h3><p>相比重排，重绘就简单多了，所谓重绘，就是当页面中元素样式的改变并不影响它在文档流中的位置时，例如更改了字体颜色,浏览器会将新样式赋予给元素并重新绘制的过程称。</p><p>常见引起浏览器绘制过程的属性包含：</p><blockquote><p>color    border-style    visibility    background<br>text-decoration    background-image    background-position    background-repeat<br>outline-color    outline    outline-style    border-radius<br>outline-width    box-shadow    background-size</p></blockquote><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>我们知道操作DOM是一个高成本的操作，不仅是因为本身js与DOM的链接访问，还包括操作DOM后会引起一连串的连锁反应（重排），因此，从性能优化角度，我们可以从以下几个方面着手：</p><ul><li><p>减少DOM操作（放弃传统操作dom的时代，基于vue/react开始数据影响视图模式）</p><ul><li><p>最小化DOM访问次数，尽量缓存访问DOM的样式信息，避免过度触发回流。</p></li><li><p>如果在一个局部方法中需要多次访问同一个dom，则先暂存它的引用。</p></li></ul></li><li><p>分离读写操作 （现代的浏览器都有渲染队列的机制）</p></li><li><p>采用更优的API替代消费高的api，转换优化消费高的集合</p><ul><li><p>用querySelectorAll()替代getElementByXX()。</p></li><li><p>开启动画的GPU加速，把渲染计算交给GPU。</p></li><li><p>少用HTML集合（类数组）来遍历，因为集合遍历比真数组遍历耗费更高。</p></li><li><p>用事件委托来减少事件处理器的数量。</p></li></ul></li><li><p>减少重排</p><ul><li><p>样式集中改变</p></li><li><p>缓存布局信息</p></li><li><p>元素批量修改</p></li><li><p>避免设置大量的style属性，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow，所以最好是使用class属性</p></li><li><p>动画效果应用到position属性为absolute或fixed的元素上（脱离文档流）</p></li><li><p>动画实现的速度的选择。比如实现一个动画，以1个像素为单位移动这样最平滑，但是reflow就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多。</p></li><li><p>不要使用table布局，因为table中某个元素旦触发了reflow，那么整个table的元素都会触发reflow。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围</p></li></ul></li><li><p>css及动画处理</p><ul><li><p>少用css表达式</p></li><li><p>减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；</p></li><li><p>动画尽量使用在绝对定位或固定定位的元素上；</p></li><li><p>隐藏在屏幕外，或在页面滚动时，尽量停止动画；</p></li></ul></li></ul><h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h3><h4 id="1-减少HTTP的请求次数和传输报文的大小"><a href="#1-减少HTTP的请求次数和传输报文的大小" class="headerlink" title="1. 减少HTTP的请求次数和传输报文的大小"></a>1. 减少HTTP的请求次数和传输报文的大小</h4><ul><li>CSS SPRITE（雪碧图、图片精灵）技术</li><li>使用字体图标（ICON FONT）或者SVG等矢量图<ul><li>减少HTTP请求次数或者减少请求内容的大小</li><li>渲染更快：因为他们是基于代码渲染的，而对于位图（png/jpg/gif）是需要先把图片编码再渲染</li><li>不容易失真变形</li><li>也可以使用webp格式图片，这种格式要小一些（但是需要服务器端支持这种格式的请求处理）</li></ul></li><li>图片懒加载（延迟加载）技术<ul><li>第一次加载页面的时候不去请求真实的图片，提高第一次渲染页面的速度</li><li>当页面加载完，把出现在用户视野区域中的图片做真实加载，没有出现的先不加载（节约流量，也能减少对服务器的请求压力）</li><li>对于数据我们也尽可能分批加载（不要一次请求过多的数据，例如分页技术）</li></ul></li><li>音视频文件取消预加载（preload=’none’），这样可以增加第一次渲染页面的速度，当需要播放的时候再加载</li><li>客户端和服务器端的数据传输尽可能基于JSON格式完成，XML格式比JSON格式要大一些（还可以基于二进制编码或者文件流格式，这种格式比文件传输好很多）</li><li>把页面中的CSS/JS/图片等文件进行合并压缩<ul><li>合并：争取CSS和JS都只导入一个（webpack可以实现自动合并压缩）</li><li>压缩：基于webpack可以压缩、对于图片自己找工具先压缩、还可以使用服务器的GZIP压缩</li></ul></li><li>图片地图：对于多次调取使用的图片（尤其是背景图），我们尽可能把它提取成为公共的样式，而不是每一次重新设置background</li><li>图片BASE64（用BASE64码代表图片，减少HTTP请求，增加浏览器渲染的速度，所以真实项目中，尤其是移动端，如果图片加载缓慢，可能BASE64一下就好了；但是，BASE64会导致文件中的代码超级恶心，不利于维护和开发，所以少使用；webpack中可以配置图片的BASE64；）</li></ul><h4 id="2-设置各种缓存、预处理和长连接机制"><a href="#2-设置各种缓存、预处理和长连接机制" class="headerlink" title="2. 设置各种缓存、预处理和长连接机制"></a>2. 设置各种缓存、预处理和长连接机制</h4><ul><li><p>把不经常更改的静态资源做缓存处理（一般做的是304或者ETAG等协商缓存）</p></li><li><p>建立 Cache-Control 和 Expires HTTP的强缓存</p></li><li><p>DNS缓存或者预处理（DNS PREFETCH），减少DNS的查找</p></li><li><p>设置本地的离线存储（manifest）或者把一些不经常更改的数据做本地存储（webstorage、indexdb）等</p></li><li><p>建立 Connection:keep-alive TCP长连接</p></li><li><p>使用HTTP2版本协议（现在用的一般都是HTTP1.1）<br>  HTTP/2.0 相比1.0有哪些重大改进？ <a href="https://www.zhihu.com/question/34074946" target="_blank" rel="noopener">https://www.zhihu.com/question/34074946</a></p></li><li><p>一个项目分为不同的域（不同的服务器），例如：资源WEB服务器、数据服务器、图片服务器、视频服务器等，这样合理利用服务器资源，但是导致过多的DNS解析</p></li></ul><h4 id="3-代码方面的性能优化"><a href="#3-代码方面的性能优化" class="headerlink" title="3. 代码方面的性能优化"></a>3. 代码方面的性能优化</h4><ul><li>减少对闭包的使用（因为过多使用闭包会产生很多不销毁的内存，处理不好的话，会导致内存溢出“栈溢出”），减少闭包的嵌套（减少作用域链的查找层级）</li><li>对于动画来说：能用CSS解决的不用JS（能够用transform处理的，不用传统的css样式，因为transform开启硬件加速，不会引发回流，再或者使用定位的元素也会好很多，因为定位的元素脱离文档流，不会对其它元素的位置造成影响），能用requestAnimationFrame解决的不用定时器<ul><li>requestAnimationFrame还有一个好处，当页面处于休眠无访问状态，动画会自己暂停，直到恢复访问才开始，而定时器是不论什么状态，只要页面不管，就一直处理</li></ul></li><li>避免使用iframe（因为iframe会嵌入其它页面，这样父页面渲染的时候，还要同时把子页面也渲染了，渲染进度会变慢）</li><li>减少直接对DOM的操作（原因是减少DOM的回流和重绘…），当代项目基本上都是基于mvvm/mvc数据驱动视图渲染的，对DOM的操作框架本身完成，性能要好很多</li><li>低耦合高内聚（基于封装的方式：方法封装、插件、组件、框架、类库等封装，减少页面中的冗余代码，提高代码使用率）</li><li>尽可能使用事件委托</li><li>避免出现死循环或者嵌套循环（嵌套循环会成倍增加循环的次数）</li><li>项目中尽可能使用异步编程来模拟出多线程的效果，避免主线程阻塞（异步操作基于PROMISE设计模式来管理）</li><li>JS中不要使用with</li><li>避免使用CSS表达式</li><li>函数的防抖和节流</li><li>减少使用eval（主要原因是防止压缩代码的时候，由于符号书写不合规，导致代码混乱）</li><li>减少filter滤镜的使用</li><li>尽可能减少选择器的层级（选择器是从右向左解析） .box a{} 和 a{}</li><li>尽可能减少TABLE布局</li><li>手动回收堆栈内存（赋值为null）<br>其他</li><li>CDN（地域分布式服务器），加服务器</li></ul><p>JS前端代码优化的108条建议<br>雅虎CSS代码优化的36条建议 <a href="https://blog.csdn.net/ime33/article/details/77862047" target="_blank" rel="noopener">https://blog.csdn.net/ime33/article/details/77862047</a></p><blockquote><p>感谢这个时代，让我们可以站在巨人的肩膀上，窥探程序世界的宏伟壮观，我愿以一颗赤子心，踏遍程序世界的千山万水！愿每一个行走在程序世界的同仁，都活成心中想要的样子，加油。</p></blockquote><p>引用文章：小白师兄 周啸天<br>链接：<a href="https://www.imooc.com/article/45936" target="_blank" rel="noopener">https://www.imooc.com/article/45936</a><br>链接：<a href="https://www.yuque.com/books/share/b09738d1-9059-4fb5-9581-95df9e85e2c6/wmu1u9" target="_blank" rel="noopener">https://www.yuque.com/books/share/b09738d1-9059-4fb5-9581-95df9e85e2c6/wmu1u9</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;细说浏览器渲染的重排与重绘&quot;&gt;&lt;a href=&quot;#细说浏览器渲染的重排与重绘&quot; class=&quot;headerlink&quot; title=&quot;细说浏览器渲染的重排与重绘&quot;&gt;&lt;/a&gt;细说浏览器渲染的重排与重绘&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;前端性能优化因为涉及到计算
      
    
    </summary>
    
    
      <category term="前端" scheme="https://wangyiye.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="指令" scheme="https://wangyiye.github.io/tags/%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>面试题JS题</title>
    <link href="https://wangyiye.github.io/2019/04/08/%E5%8E%9F%E7%90%86%E9%A2%98/"/>
    <id>https://wangyiye.github.io/2019/04/08/原理题/</id>
    <published>2019-04-08T10:51:32.000Z</published>
    <updated>2019-05-08T10:51:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-——-面试题合集1"><a href="#JavaScript-——-面试题合集1" class="headerlink" title="JavaScript —— 面试题合集1"></a>JavaScript —— 面试题合集1</h2><h4 id="call-和-apply-的区别是什么，哪个性能更好一些"><a href="#call-和-apply-的区别是什么，哪个性能更好一些" class="headerlink" title="call 和 apply 的区别是什么，哪个性能更好一些"></a>call 和 apply 的区别是什么，哪个性能更好一些</h4><p>call的性能要比apply好一些，（传递给函数的参数超过三个的时候差距明显）后期开发过程中偏向使用call<br>性能检测的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.time(&apos;A&apos;);</span><br><span class="line">for(let i = 0;i&lt;9;i++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.timeEnd(&apos;A&apos;)</span><br></pre></td></tr></table></figure><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><ol><li>箭头函数语法上上普通函数更加简洁（ES6中的每一种函数都可以使用形参赋值和剩余运算符）iiiiiiiiiiiiiii</li><li>箭头函数没有this，他里面出现的this继承函数所处上下文中的this，使用call/apply等任何方式无法改变。</li><li>箭头函数没有ArgumentS（类数组）只能基于…arg获取传递的参数集合（数组）；</li><li>箭头函数不能被new执行（因为：箭头函数没有prototype也没有this）<h4 id="实现-5-add-3-minus-2-，使其输出结果为：6"><a href="#实现-5-add-3-minus-2-，使其输出结果为：6" class="headerlink" title="实现 (5).add(3).minus(2) ，使其输出结果为：6"></a>实现 (5).add(3).minus(2) ，使其输出结果为：6</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> ~ function () &#123;</span><br><span class="line">//=&gt;每一个方法执行完，都要返回NUMBER这个类的实例，这样才可以继续调取NUMBER类原型中的方法（链式写法）</span><br><span class="line">function check(n) &#123;</span><br><span class="line">n = Number(n);</span><br><span class="line">return isNaN(n) ? 0 : n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(n) &#123;</span><br><span class="line">n = check(n);</span><br><span class="line">return this + n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function minus(n) &#123;</span><br><span class="line">n = check(n);</span><br><span class="line">return this - n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Number.prototype.add = add;</span><br><span class="line">Number.prototype.minus = minus;</span><br><span class="line">//  [&quot;add&quot;, &quot;minus&quot;].forEach(item =&gt; &#123;</span><br><span class="line">// Number.prototype[item] = eval(item);</span><br><span class="line">// &#125;); </span><br><span class="line">&#125;();</span><br><span class="line">console.log((5).add(3).minus(2));</span><br></pre></td></tr></table></figure></li></ol><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//=&gt;回调函数：把一个函数B作为实参传递给另外一个函数A，函数A在执行的时候，可以把传递进来的函数B去执行（执行N次，可传值，可改THIS）</span><br><span class="line"> function each(arr, callBack) &#123;</span><br><span class="line">//=&gt;callBack:function(item, index)&#123;&#125;</span><br><span class="line"> for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line"> let flag = callBack.call(arr, arr[i], i);</span><br><span class="line">//=&gt;接受回调函数返回的结果，如果是FALSE，我们结束循环</span><br><span class="line">if (flag === false) &#123;</span><br><span class="line"> break;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> each([10, 20, 30, 40], function (item, index) &#123;</span><br><span class="line">//=&gt;this:原始操作数组</span><br><span class="line"> if (index &gt; 1) &#123;</span><br><span class="line"> return false;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h4 id="如何把一个字符串的大小写取反（大写变小写小写变大写），例如-’AbC’-变成-‘aBc’"><a href="#如何把一个字符串的大小写取反（大写变小写小写变大写），例如-’AbC’-变成-‘aBc’" class="headerlink" title="如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC’ 变成 ‘aBc’"></a>如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC’ 变成 ‘aBc’</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;zhufengPEIxun的周老师很帅！吁*100！HAHA&quot;;</span><br><span class="line">str = str.replace(/[a-zA-Z]/g, content =&gt; &#123;</span><br><span class="line">//=&gt;content:每一次正则匹配的结果</span><br><span class="line">//验证是否为大写字母：把字母转换为大写后看和之前是否一样，如果一样，之前也是大写的；在ASCII表中找到大写字母的取值范围进行判断（65-90）；</span><br><span class="line">// content.toUpperCase()===content</span><br><span class="line">// content.charCodeAt()&gt;=65 &amp;&amp; content.charCodeAt()&lt;=90</span><br><span class="line">return content.toUpperCase() === content ? content.toLowerCase() : content.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line">console.log(str);</span><br></pre></td></tr></table></figure><h4 id="实现一个字符串匹配算法，从字符串-S-中，查找是否存在字符串-T，若存在返回所在位置，不存在返回-1！（如果不能基于indexOf-includes等内置的方法，你会如何处理呢？）"><a href="#实现一个字符串匹配算法，从字符串-S-中，查找是否存在字符串-T，若存在返回所在位置，不存在返回-1！（如果不能基于indexOf-includes等内置的方法，你会如何处理呢？）" class="headerlink" title="实现一个字符串匹配算法，从字符串 S 中，查找是否存在字符串 T，若存在返回所在位置，不存在返回-1！（如果不能基于indexOf/includes等内置的方法，你会如何处理呢？）"></a>实现一个字符串匹配算法，从字符串 S 中，查找是否存在字符串 T，若存在返回所在位置，不存在返回-1！（如果不能基于indexOf/includes等内置的方法，你会如何处理呢？）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">~ function () &#123;</span><br><span class="line">/*</span><br><span class="line"> * 循环原始字符串中的每一项，让每一项从当前位置向后截取T.length个字符，然后和T进行比较，如果不一样，继续循环；如果一样返回当前索引即可（循环结束）；</span><br><span class="line"> */</span><br><span class="line">function myIndexOf(T) &#123;</span><br><span class="line">//=&gt;THIS:S</span><br><span class="line">let lenT = T.length,</span><br><span class="line">lenS = this.length,</span><br><span class="line">res = -1;</span><br><span class="line">if (lenT &gt; lenS) return -1;</span><br><span class="line">for (let i = 0; i &lt;= lenS - lenT; i++) &#123;</span><br><span class="line">if (this.substr(i, lenT) === T) &#123;</span><br><span class="line">res = i;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 正则处理 </span><br><span class="line"> */</span><br><span class="line">function myIndexOf(T) &#123;</span><br><span class="line">//=&gt;THIS:S</span><br><span class="line">let reg = new RegExp(T),</span><br><span class="line">res = reg.exec(this);</span><br><span class="line">return res === null ? -1 : res.index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String.prototype.myIndexOf = myIndexOf;</span><br><span class="line">&#125;();</span><br><span class="line">// let S = &quot;zhufengpeixun&quot;,</span><br><span class="line">// T = &quot;pei&quot;;</span><br><span class="line">// console.log(S.myIndexOf(T));</span><br></pre></td></tr></table></figure><h4 id="输出下面代码运行结果"><a href="#输出下面代码运行结果" class="headerlink" title="输出下面代码运行结果"></a>输出下面代码运行结果</h4><p><img src="/2019/04/08/原理题/1.png" alt="Alt text"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* //example 1</span><br><span class="line">var a=&#123;&#125;, b=&apos;123&apos;, c=123;  </span><br><span class="line">a[b]=&apos;b&apos;;</span><br><span class="line">a[c]=&apos;c&apos;;  </span><br><span class="line">console.log(a[b]); //=&gt;c  因为：a[&quot;123&quot;] &lt;=&gt; a[123]</span><br><span class="line"></span><br><span class="line">//example 2</span><br><span class="line">var a=&#123;&#125;, b=Symbol(&apos;123&apos;), c=Symbol(&apos;123&apos;);  </span><br><span class="line">a[b]=&apos;b&apos;;</span><br><span class="line">a[c]=&apos;c&apos;;  </span><br><span class="line">console.log(a[b]);  //=&gt;Symbol是ES6中新增的数据类型  typeof Symbol(&apos;123&apos;)===&quot;symbol&quot;  它创建出来的值是唯一值  Symbol(&apos;123&apos;)===Symbol(&apos;123&apos;):FALSE</span><br><span class="line"></span><br><span class="line">//example 3</span><br><span class="line">var a=&#123;&#125;, b=&#123;key:&apos;123&apos;&#125;, c=&#123;key:&apos;456&apos;&#125;;  </span><br><span class="line">a[b]=&apos;b&apos;;</span><br><span class="line">a[c]=&apos;c&apos;;  </span><br><span class="line">console.log(a[b]);</span><br><span class="line">//1.对象的属性名不能是一个对象（遇到对象属性名，会默认转换为字符串）</span><br><span class="line">// obj=&#123;&#125;  arr=[12,23]  obj[arr]=&apos;珠峰&apos;  obj=&gt;&#123;&quot;12,23&quot;:&quot;珠峰&quot;&#125;</span><br><span class="line">//2.普通对象.toString() 调取的是Object.prototype上的方法（这个方法是用来检测数据类型的）</span><br><span class="line">// obj=&#123;&#125;  obj.toString()=&gt;&quot;[object Object]&quot; </span><br><span class="line">// obj[b]=&apos;b&apos;  =&gt; obj[&quot;[object Object]&quot;]=&apos;b&apos; */</span><br></pre></td></tr></table></figure><h4 id="在输入框中如何判断输入的是一个正确的网址，例如：用户输入一个字符串，验证是否符合URL网址的格式"><a href="#在输入框中如何判断输入的是一个正确的网址，例如：用户输入一个字符串，验证是否符合URL网址的格式" class="headerlink" title="在输入框中如何判断输入的是一个正确的网址，例如：用户输入一个字符串，验证是否符合URL网址的格式"></a>在输入框中如何判断输入的是一个正确的网址，例如：用户输入一个字符串，验证是否符合URL网址的格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;https://www.zhufengpeixun.com.cn&quot;;</span><br><span class="line">let reg = /^(?:(http|https|ftp):\/\/)?((?:[\w-]+\.)+[a-z0-9]+)((?:\/[^/?#]*)+)?(\?[^#]+)?(#.+)?$/i;</span><br><span class="line">console.log(reg.exec(str));</span><br><span class="line">//=&gt;URL格式</span><br><span class="line">//1.协议://  http/https/ftp</span><br><span class="line">//2.域名</span><br><span class="line">// www.zhufengpeixun.cn</span><br><span class="line">// zhufengpeixun.cn</span><br><span class="line">// kbs.sports.qq.com</span><br><span class="line">// kbs.sports.qq.com.cn</span><br><span class="line">//3.请求路径</span><br><span class="line">// /</span><br><span class="line">// /index.html</span><br><span class="line">// /stu/index.html</span><br><span class="line">// /stu/</span><br><span class="line">//4.问号传参</span><br><span class="line">// ?xxx=xxx&amp;xxx=xxx</span><br><span class="line">//5.哈希值</span><br><span class="line">// #xxx</span><br></pre></td></tr></table></figure><h4 id="编写代码实现图片的懒加载"><a href="#编写代码实现图片的懒加载" class="headerlink" title="编写代码实现图片的懒加载"></a>编写代码实现图片的懒加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">let $imgBox = $(&apos;.imgBox&apos;),</span><br><span class="line">$img = $imgBox.children(&apos;img&apos;),</span><br><span class="line">$window = $(window);</span><br><span class="line"></span><br><span class="line">//=&gt;JQ中的事件绑定支持多事件绑定：window.onload &amp; window.onscroll 两个事件触发的时候执行相同的事情</span><br><span class="line">$window.on(&apos;load scroll&apos;, function () &#123;</span><br><span class="line">if ($img.attr(&apos;isLoad&apos;) === &apos;true&apos;) &#123;</span><br><span class="line">//=&gt;之前加载过则不会重新加载</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">let $A = $imgBox.outerHeight() + $imgBox.offset().top,</span><br><span class="line">$B = $window.outerHeight() + $window.scrollTop();</span><br><span class="line">if ($A &lt;= $B) &#123;</span><br><span class="line">//=&gt;加载真实图片</span><br><span class="line">$img.attr(&apos;src&apos;, $img.attr(&apos;data-img&apos;));</span><br><span class="line">$img.on(&apos;load&apos;, function () &#123;</span><br><span class="line">//=&gt;加载成功：fadeIn是JQ中的渐现动画</span><br><span class="line">// $img.css(&apos;display&apos;, &apos;block&apos;);</span><br><span class="line">$img.stop().fadeIn();</span><br><span class="line">&#125;);</span><br><span class="line">$img.attr(&apos;isLoad&apos;, true); //=&gt;ATTR存储的自定义属性值都是字符串&quot;true&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;); */</span><br><span class="line"></span><br><span class="line">let $container = $(&apos;.container&apos;),</span><br><span class="line">$imgBoxs = null,</span><br><span class="line">$window = $(window);</span><br><span class="line"></span><br><span class="line">//=&gt;造点假数据 new Array(20).fill(null)创建长度为20的数组，每一项用null填充</span><br><span class="line">let str = ``;</span><br><span class="line">new Array(20).fill(null).forEach(item =&gt; &#123;</span><br><span class="line">str += `&lt;div class=&quot;imgBox&quot;&gt;</span><br><span class="line">&lt;img src=&quot;&quot; alt=&quot;&quot; data-img=&quot;http://www.zhufengpeixun.cn/main/img/banner10.png&quot;&gt;</span><br><span class="line">&lt;/div&gt;`;</span><br><span class="line">&#125;);</span><br><span class="line">$container.html(str);</span><br><span class="line">$imgBoxs = $container.children(&apos;.imgBox&apos;);</span><br><span class="line"></span><br><span class="line">//=&gt;多张图片延迟加载</span><br><span class="line">$window.on(&apos;load scroll&apos;, function () &#123;</span><br><span class="line">//$B:获取浏览器底边框距离BODY的距离</span><br><span class="line">let $B = $window.outerHeight() + $window.scrollTop();</span><br><span class="line">//循环每一个图片区域，根据自己区域距离BODY的距离，计算出里面的图片是否加载</span><br><span class="line">$imgBoxs.each((index, item) =&gt; &#123;</span><br><span class="line">let $item = $(item),</span><br><span class="line">$itemA = $item.outerHeight() + $item.offset().top,</span><br><span class="line">isLoad = $item.attr(&apos;isLoad&apos;);</span><br><span class="line">if ($itemA &lt;= $B &amp;&amp; isLoad !== &apos;true&apos;) &#123;</span><br><span class="line">$item.attr(&apos;isLoad&apos;, true);</span><br><span class="line">//加载当前区域中的图片</span><br><span class="line">let $img = $item.children(&apos;img&apos;);</span><br><span class="line">$img.attr(&apos;src&apos;, $img.attr(&apos;data-img&apos;));</span><br><span class="line">$img.on(&apos;load&apos;, () =&gt; $img.stop().fadeIn());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);o7</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="编写一条正则，用来验证此规则：一个6-16位的字符串，必须同时包含有大小写字母和数字"><a href="#编写一条正则，用来验证此规则：一个6-16位的字符串，必须同时包含有大小写字母和数字" class="headerlink" title="编写一条正则，用来验证此规则：一个6~16位的字符串，必须同时包含有大小写字母和数字"></a>编写一条正则，用来验证此规则：一个6~16位的字符串，必须同时包含有大小写字母和数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let reg = /(?!^[a-zA-Z]+$)(?!^[0-9]+$)(?!^[a-z0-9]+$)(?!^[A-Z0-9]+$)^[a-zA-Z0-9]&#123;6,16&#125;$/;</span><br><span class="line"></span><br><span class="line">/* 1-10位：数字、字母、下划线组成字符串，必须有_ */</span><br><span class="line">// let reg = /(?!^[a-zA-Z0-9]+$)^\w&#123;1,10&#125;$/;</span><br><span class="line"></span><br><span class="line">/* 字符串中包含 “\w”，但是必须包含_ */</span><br><span class="line">// let reg = /(?=_)\w+/;</span><br></pre></td></tr></table></figure><h4 id="完成如下需求"><a href="#完成如下需求" class="headerlink" title="完成如下需求"></a>完成如下需求</h4><p><img src="/2019/04/08/原理题/2.png" alt="Alt text"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* 实现一个$attr(name,value)遍历</span><br><span class="line"> * 属性为name</span><br><span class="line"> * 值为value的元素集合</span><br><span class="line"> * </span><br><span class="line"> * 例如下面示例:</span><br><span class="line"> */</span><br><span class="line"> function $attr(property, value) &#123;</span><br><span class="line">//=&gt;获取当前页面中所有的标签</span><br><span class="line">let elements = document.getElementsByTagName(&apos;*&apos;),</span><br><span class="line">arr = [];</span><br><span class="line">// [].forEach.call(elements, item =&gt; &#123;&#125;);</span><br><span class="line">elements = Array.from(elements); //=&gt;把非数组转换为数组</span><br><span class="line">elements.forEach(item =&gt; &#123;</span><br><span class="line">//=&gt;存储的是当前元素PROPERTY对应的属性值</span><br><span class="line">let itemValue = item.getAttribute(property);</span><br><span class="line">if (property === &apos;class&apos;) &#123;</span><br><span class="line">//=&gt;样式类属性名要特殊的处理</span><br><span class="line">new RegExp(&quot;\\b&quot; + value + &quot;\\b&quot;).test(itemValue) ? arr.push(item) : null;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if (itemValue === value) &#123;</span><br><span class="line">//=&gt;获取的值和传递的值校验成功：当前就是我们想要的</span><br><span class="line">arr.push(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">console.log($attr(&apos;class&apos;, &apos;box&apos;));</span><br></pre></td></tr></table></figure><h4 id="英文字母汉字组成的字符串，用正则给英文单词前后加空格"><a href="#英文字母汉字组成的字符串，用正则给英文单词前后加空格" class="headerlink" title="英文字母汉字组成的字符串，用正则给英文单词前后加空格"></a>英文字母汉字组成的字符串，用正则给英文单词前后加空格</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;no作no死，你能你can，不能no哔哔！&quot;,</span><br><span class="line">reg = /\b[a-z]+\b/ig;</span><br><span class="line">str = str.replace(reg, value =&gt; &#123;</span><br><span class="line">return &quot; &quot; + value + &quot; &quot;;</span><br><span class="line"> &#125;).trim();            //=&gt;String.prototype.trim/.trimLeft/.trimRight 去除字符串首尾空格</span><br><span class="line"> console.log(str);</span><br></pre></td></tr></table></figure><h4 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//=&gt;使用ES6中提供的 Array.prototype.flat 处理</span><br><span class="line">// arr = arr.flat(Infinity);</span><br><span class="line"></span><br><span class="line">//=&gt;把数组直接变为字符串即可（数组TOSTRING之后，不管你有多少级，最后都会变为以逗号分隔的字符串，没有中括号和所谓的层级了），相当于直接的扁平化了</span><br><span class="line">// arr = arr.toString().split(&apos;,&apos;).map(item =&gt; &#123;</span><br><span class="line">// return Number(item);</span><br><span class="line">// &#125;);</span><br><span class="line"></span><br><span class="line">//=&gt;JSON.stringify也可以扁平化数组</span><br><span class="line">// JSON.stringify(arr) : &quot;[[1,2,2],[3,4,5,5],[6,7,8,9,...&quot;</span><br><span class="line">// replace(/(\[|\])/g, &apos;&apos;) : &quot;1,2,2,3,4,5,5,6,7,8,9...&quot;</span><br><span class="line">// arr = JSON.stringify(arr).replace(/(\[|\])/g, &apos;&apos;).split(&apos;,&apos;).map(item =&gt; Number(item));</span><br><span class="line"></span><br><span class="line">//=&gt;基于数组的some方法进行判断检测：验证数组中的某一项有没有符合函数中提供的规则的</span><br><span class="line">//=&gt;find和some的区别：some返回的是boolean，find找到符合规则的，返回当前这一项，没找到符合规则的，返回undefined</span><br><span class="line">//=&gt;Array.isArray([val])：检测某个值是否为数组类型（挺准的）</span><br><span class="line">/* var A = [2, 3, 4, 5];</span><br><span class="line">var B = A.find(item =&gt; &#123;</span><br><span class="line">return item &lt; 6;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(B); */</span><br><span class="line">// while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line">// arr = [].concat(...arr);</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">//=&gt;自己递归处理</span><br><span class="line">~ function () &#123;</span><br><span class="line">function myFlat() &#123;</span><br><span class="line">let result = [],</span><br><span class="line">_this = this;</span><br><span class="line">//=&gt;循环ARR中的每一项，把不是数组的存储到新数组中</span><br><span class="line">let fn = (arr) =&gt; &#123;</span><br><span class="line">for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">let item = arr[i];</span><br><span class="line">if (Array.isArray(item)) &#123;</span><br><span class="line">fn(item);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">result.push(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">fn(_this);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">Array.prototype.myFlat = myFlat;</span><br><span class="line">&#125;();</span><br><span class="line">arr = arr.myFlat();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//=&gt;基于ES6中的new Set()去重数组（也可以自己写方法）</span><br><span class="line">// [...new Set(arr)]</span><br><span class="line">// Array.from(new Set(arr))</span><br><span class="line">arr = Array.from(new Set(arr)).sort((a, b) =&gt; a - b);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><h4 id="重构内置new方法"><a href="#重构内置new方法" class="headerlink" title="重构内置new方法"></a>重构内置new方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function Dog(name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.bark = function () &#123;</span><br><span class="line">console.log(&apos;wangwang&apos;);</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.sayName = function () &#123;</span><br><span class="line">console.log(&apos;my name is &apos; + this.name);</span><br><span class="line">&#125;</span><br><span class="line">//=&gt;Fn当前要NEW的类  =&gt;Dog</span><br><span class="line">//=&gt;ARG后期需要给构造函数传递的参数信息  =&gt;[&apos;三毛&apos;]</span><br><span class="line">function _new(Fn, ...arg) &#123;</span><br><span class="line">//=&gt;创建一个空对象，让他的原型链指向Fn.prototype（作为Fn的一个实例）</span><br><span class="line">//=&gt;Object.create([AA对象])：创建一个空对象obj，并且让空对象obj作为AA对象所属构造函数的实例（obj.__proto__=AA）</span><br><span class="line">// let obj = &#123;&#125;;</span><br><span class="line">// obj.__proto__ = Fn.prototype;</span><br><span class="line">let obj = Object.create(Fn.prototype);</span><br><span class="line">Fn.call(obj, ...arg);</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line">let sanmao = _new(Dog, &apos;三毛&apos;);</span><br><span class="line">/* </span><br><span class="line"> * let sanmao=new Dog(&apos;三毛&apos;); </span><br><span class="line"> *   1.像普通函数执行一样，形成一个私有的作用域</span><br><span class="line"> *     + 形参赋值</span><br><span class="line"> *     + 变量提升</span><br><span class="line"> *   2.默认创建一个对象,让函数中的this执行这个对象,这个对象就是当前类的一个实例</span><br><span class="line"> *   3.代码执行</span><br><span class="line"> *   4.默认把创建的对象返回</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//=&gt;基于内置的new关键词，我们可以创建Dog的一个实例sanmao，实例可以调取原型上的属性和方法，现在的需求是：自己实现一个_new方法，也能模拟出内置new后的结果</span><br><span class="line">// function _new() &#123;</span><br><span class="line">// //=&gt;完成你的代码</span><br><span class="line">// &#125;</span><br><span class="line">sanmao.bark(); //=&gt;&quot;wangwang&quot;</span><br><span class="line">sanmao.sayName(); //=&gt;&quot;my name is 三毛&quot;</span><br><span class="line">console.log(sanmao instanceof Dog); //=&gt;true</span><br></pre></td></tr></table></figure><h4 id="两个数组和并为一个数组"><a href="#两个数组和并为一个数组" class="headerlink" title="两个数组和并为一个数组"></a>两个数组和并为一个数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let ary1 = [&apos;D1&apos;, &apos;D2&apos;, &apos;A1&apos;, &apos;A2&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;B1&apos;, &apos;B2&apos;];</span><br><span class="line">let ary2 = [&apos;B&apos;, &apos;A&apos;, &apos;D&apos;, &apos;C&apos;];</span><br><span class="line">//=&gt;合并后的数组为：[&apos;D1&apos;, &apos;D2&apos;,&apos;D&apos;, &apos;A1&apos;, &apos;A2&apos;,&apos;A&apos;, &apos;C1&apos;, &apos;C2&apos;,&apos;C&apos; ,&apos;B1&apos;, &apos;B2&apos;,&apos;B&apos;]</span><br><span class="line">ary2 = ary2.map(item =&gt; item + &apos;珠峰&apos;);</span><br><span class="line">let arr = ary1.concat(ary2);</span><br><span class="line">arr = arr.sort((a, b) =&gt; a.localeCompare(b)).map(item =&gt; &#123;</span><br><span class="line">return item.replace(&apos;珠峰&apos;, &apos;&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr); </span><br><span class="line"></span><br><span class="line">/* let n = 0;</span><br><span class="line">for (let i = 0; i &lt; ary2.length; i++) &#123;</span><br><span class="line">let item2 = ary2[i];</span><br><span class="line">for (let k = 0; k &lt; ary1.length; k++) &#123;</span><br><span class="line">let item1 = ary1[k];</span><br><span class="line">if (item1.includes(item2)) &#123;</span><br><span class="line">//=&gt;如果包含就记录一下当前这一项的索引位置（后面还有包含的会重新记录这个值）</span><br><span class="line">n = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//=&gt;把当前ITEM2这一项插入到ARY1中N的后面</span><br><span class="line">ary1.splice(n + 1, 0, item2);</span><br><span class="line">&#125;</span><br><span class="line">console.log(ary1); */</span><br></pre></td></tr></table></figure><h4 id="改造下面代码，使之输出0-9"><a href="#改造下面代码，使之输出0-9" class="headerlink" title="改造下面代码，使之输出0-9"></a>改造下面代码，使之输出0-9</h4><p><img src="/2019/04/08/原理题/3.png" alt="Alt text"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//=&gt;定时器是异步编程：每一轮循环设置定时器，无需等定时器触发执行，继续下一轮循环（定时器触发的时候，循环已经结束了）</span><br><span class="line">/* for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">//=&gt;LET存在块级作用域，每一次循环都会在当前块作用域中形成一个私有变量i存储0~9</span><br><span class="line">//当定时器执行的时候，所使用的i就是所处块作用域中的i</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">console.log(i);</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125; */</span><br><span class="line"></span><br><span class="line">//=&gt;闭包解决</span><br><span class="line">/* for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">~ function (i) &#123;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">console.log(i);</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;(i);</span><br><span class="line">&#125; */</span><br><span class="line">/* for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">setTimeout((i =&gt; () =&gt; console.log(i))(i), 1000);</span><br><span class="line">&#125; */</span><br><span class="line"></span><br><span class="line">//=&gt;可以基于bind的预先处理机制：在循环的时候就把每次执行函数需要输出的结果，预先传给函数即可</span><br><span class="line">/* var fn = function (i) &#123;</span><br><span class="line">console.log(i);</span><br><span class="line">&#125;;</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">setTimeout(fn.bind(null, i), 1000);</span><br><span class="line">&#125; */</span><br></pre></td></tr></table></figure><h4 id="下面代码输出的结果是多少，为什么？如何改造一下，就能让其输出-20-10？"><a href="#下面代码输出的结果是多少，为什么？如何改造一下，就能让其输出-20-10？" class="headerlink" title="下面代码输出的结果是多少，为什么？如何改造一下，就能让其输出 20 10？"></a>下面代码输出的结果是多少，为什么？如何改造一下，就能让其输出 20 10？</h4><p><img src="/2019/04/08/原理题/4.png" alt="Alt text"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* var b = 10;</span><br><span class="line">(function b() &#123;</span><br><span class="line">b = 20;</span><br><span class="line">console.log(b); //=&gt;函数</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(b); //=&gt;10 */</span><br><span class="line"></span><br><span class="line">/* let fn = function AAA() &#123;</span><br><span class="line">// &quot;use strict&quot;;</span><br><span class="line">// AAA = 1000; //=&gt;Uncaught TypeError: Assignment to constant variable.</span><br><span class="line">console.log(AAA); //=&gt;当前函数</span><br><span class="line">&#125;;</span><br><span class="line">// AAA(); //=&gt;Uncaught ReferenceError: AAA is not defined  </span><br><span class="line">// 1.本应匿名的函数如果设置了函数名，在外面还是无法调用，但是在函数里面是可以使用的</span><br><span class="line">// 2.而且类似于创建常量一样，这个名字存储的值不能再被修改（非严格模式下不错报，但是不会有任何的效果，严格模式下直接报错，我们可以把AAA理解为是用 const 创建出来的）</span><br><span class="line">fn(); */</span><br><span class="line"></span><br><span class="line">/* var b = 10;</span><br><span class="line">(function b(b) &#123;</span><br><span class="line">b = 20;</span><br><span class="line">console.log(b); //=&gt;20 里面的b一定需要是私有的，不能是全局的（声明它或者改为形参）</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(b); //=&gt;10 */</span><br></pre></td></tr></table></figure><h4 id="对象比较"><a href="#对象比较" class="headerlink" title="对象比较"></a>对象比较</h4><p><img src="/2019/04/08/原理题/5.png" alt="Alt text"></p><p>==进行比较的时候，如果左边数据类型不一样，则先转换为相同的数据类型，然后进行比较。</p><ol><li>{} == {} 对象比较的是堆内存的地址</li><li><code>null == undefined   true  null === undefined false</code></li><li>NaN == NaN  false</li><li>[12] == ‘12’   对象和字符串比较 是把对象to string（）转换为字符串后再Number再进行比较</li><li>剩余的情况比较都是转换为数字再进行比较</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//=&gt;对象和数字比较：先把对象.toString()变为字符串，然后再转换为数字</span><br><span class="line"> var a = &#123;</span><br><span class="line">n: 0,</span><br><span class="line">//=&gt;私有的属性方法</span><br><span class="line">toString: function () &#123;</span><br><span class="line">return ++this.n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">// a.toString(); //=&gt;此时调取的就不再是Object.prototype.toString了，调取的是自己私有的</span><br><span class="line">if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;</span><br><span class="line">console.log(&apos;OK&apos;);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//=&gt;shift:删除数组第一项，把删除的内容返回，原有数组改变</span><br><span class="line"> let a = [1, 2, 3];</span><br><span class="line"> a.toString = a.shift;</span><br><span class="line"> if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;</span><br><span class="line">console.log(&apos;OK&apos;);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> * ES6中新增加的一些方法</span><br><span class="line"> *   String.fromCharCode([n])  &lt;=&gt; &quot;z&quot;.charCodeAt()  </span><br><span class="line"> *   Array.from()</span><br><span class="line"> *   Array.isArray() </span><br><span class="line"> *   Object.create([OBJ])</span><br><span class="line"> *   Object.defineProperty()</span><br><span class="line"> </span><br><span class="line"> let obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &apos;name&apos;, &#123;</span><br><span class="line">get: function () &#123;</span><br><span class="line">console.log(&apos;哈哈&apos;);</span><br><span class="line">return &quot;珠峰培训&quot;;</span><br><span class="line">&#125;,</span><br><span class="line">set: function () &#123;</span><br><span class="line">console.log(&apos;呵呵呵&apos;);</span><br><span class="line">this.value = &quot;呵呵呵&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">Object.defineProperty(window, &apos;a&apos;, &#123;</span><br><span class="line">get: function () &#123;</span><br><span class="line">//=&gt;this:window.a</span><br><span class="line">this.value ? this.value++ : this.value = 1;</span><br><span class="line">return this.value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;</span><br><span class="line">console.log(&apos;OK&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="下面代码的输出结果？push源码"><a href="#下面代码的输出结果？push源码" class="headerlink" title="下面代码的输出结果？push源码"></a>下面代码的输出结果？push源码</h4><p><img src="/2019/04/08/原理题/6.png" alt="Alt text"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.push = function @@(val) &#123;</span><br><span class="line">this[this.length] = val;</span><br><span class="line">//=&gt;this.length在原来的基础上加1</span><br><span class="line">return this.length;</span><br><span class="line">&#125;</span><br><span class="line"> let obj = &#123;</span><br><span class="line">2: 3, //=&gt;1</span><br><span class="line">3: 4, //=&gt;2</span><br><span class="line">length: 2, //=&gt;3/4</span><br><span class="line">push: Array.prototype.push</span><br><span class="line">&#125;</span><br><span class="line">obj.push(1);</span><br><span class="line">//=&gt;@@(1)  //=&gt;this:obj  //=&gt;obj[obj.length]=1  //=&gt;obj[2]=1  //=&gt;obj.length=3</span><br><span class="line">obj.push(2);</span><br><span class="line">//=&gt;@@(2)  //=&gt;this:obj  //=&gt;obj[obj.length]=2  //=&gt;obj[3]=2  //=&gt;obj.length=4</span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure><h4 id="冒泡排序如何实现，时间复杂度是多少，-还可以如何改进？"><a href="#冒泡排序如何实现，时间复杂度是多少，-还可以如何改进？" class="headerlink" title="冒泡排序如何实现，时间复杂度是多少， 还可以如何改进？"></a>冒泡排序如何实现，时间复杂度是多少， 还可以如何改进？</h4><h4 id="完成如下需求-1"><a href="#完成如下需求-1" class="headerlink" title="完成如下需求"></a>完成如下需求</h4><p><img src="/2019/04/08/原理题/7.png" alt="Alt text"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// let obj = &#123;</span><br><span class="line">// 1: 222,</span><br><span class="line">// 2: 123,</span><br><span class="line">// 5: 888</span><br><span class="line">// &#125;;</span><br><span class="line">// let arr = new Array(12).fill(null).map((item, index) =&gt; &#123;</span><br><span class="line">// return obj[index + 1] || null;</span><br><span class="line">// &#125;);</span><br><span class="line">// console.log(arr);</span><br><span class="line"></span><br><span class="line">// let obj = &#123;</span><br><span class="line">// 1: 222,</span><br><span class="line">// 2: 123,</span><br><span class="line">// 5: 888</span><br><span class="line">// &#125;;</span><br><span class="line">// obj.length = 13;</span><br><span class="line">// let arr = Array.from(obj).slice(1).map(item =&gt; &#123;</span><br><span class="line">// return typeof item === &quot;undefined&quot; ? null : item;</span><br><span class="line">// &#125;);</span><br><span class="line">// console.log(arr);</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">1: 222,</span><br><span class="line">2: 123,</span><br><span class="line">5: 888</span><br><span class="line">&#125;;</span><br><span class="line">//=&gt;Object.keys(obj):获取obj中所有的属性名，以数组的方式返回</span><br><span class="line">// console.log(Object.keys(obj)); //=&gt;[&quot;1&quot;,&quot;2&quot;,&quot;5&quot;]</span><br><span class="line">let arr = new Array(12).fill(null);</span><br><span class="line">Object.keys(obj).forEach(item =&gt; &#123;</span><br><span class="line">arr[item - 1] = obj[item];</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><h4 id="给定两个数组，-写一个方法来计算它们的交集"><a href="#给定两个数组，-写一个方法来计算它们的交集" class="headerlink" title="给定两个数组， 写一个方法来计算它们的交集"></a>给定两个数组， 写一个方法来计算它们的交集</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> let nums1 = [12, 23, 34, 23, 45, 34, 25, 46, 35];</span><br><span class="line">let nums2 = [10, 35, 24, 23, 36, 47, 56];</span><br><span class="line">let arr = [];</span><br><span class="line">nums1.forEach((item, index) =&gt; &#123;</span><br><span class="line">//=&gt;index是第一个数组当前项的索引</span><br><span class="line">//=&gt;n当前项在第二个数组中找到相同那一项的索引</span><br><span class="line">let n = nums2.indexOf(item);</span><br><span class="line">if (n &gt;= 0) &#123;</span><br><span class="line">arr.push(item);</span><br><span class="line">nums1.splice(index, 1);</span><br><span class="line">nums2.splice(n, 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;); </span><br><span class="line">// console.log(arr);</span><br></pre></td></tr></table></figure><h4 id="算法题「旋转数组」"><a href="#算法题「旋转数组」" class="headerlink" title="算法题「旋转数组」"></a>算法题「旋转数组」</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">旋转数组</span><br><span class="line">给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数</span><br><span class="line">输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3</span><br><span class="line">输出: [5, 6, 7, 1, 2, 3, 4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7, 1, 2, 3, 4, 5, 6]</span><br><span class="line">向右旋转 2 步: [6, 7, 1, 2, 3, 4, 5]</span><br><span class="line">向右旋转 3 步: [5, 6, 7, 1, 2, 3, 4]</span><br><span class="line">​</span><br><span class="line">输入: [-1, -100, 3, 99] 和 k = 2</span><br><span class="line">输出: [3, 99, -1, -100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99, -1, -100, 3]</span><br><span class="line">向右旋转 2 步: [3, 99, -1, -100] </span><br><span class="line">*/</span><br><span class="line">/* function rotate(k) &#123;</span><br><span class="line">//=&gt;参数处理</span><br><span class="line">if (k &lt; 0 || k === 0 || k === this.length) return this;</span><br><span class="line">if (k &gt; this.length) k = k % this.length;</span><br><span class="line">//=&gt;旋转数组</span><br><span class="line">// return this.slice(-k).concat(this.slice(0, this.length - k));</span><br><span class="line">// return [...this.splice(this.length - k), ...this];</span><br><span class="line"></span><br><span class="line">/!* for (let i = 0; i &lt; k; i++) &#123;</span><br><span class="line">this.unshift(this.pop());</span><br><span class="line">&#125; *!/</span><br><span class="line">new Array(k).fill(&apos;&apos;).forEach(() =&gt; this.unshift(this.pop()));</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line">Array.prototype.rotate = rotate;</span><br><span class="line"></span><br><span class="line">let arr = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line">console.log(arr.rotate(3)); */</span><br></pre></td></tr></table></figure><h4 id="函数柯理化：预先处理思想（利用闭包的机制）"><a href="#函数柯理化：预先处理思想（利用闭包的机制）" class="headerlink" title="函数柯理化：预先处理思想（利用闭包的机制）"></a>函数柯理化：预先处理思想（利用闭包的机制）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/* 函数柯理化：预先处理的思想（利用闭包的机制） */</span><br><span class="line">/* function fn(x)&#123;</span><br><span class="line">//=&gt;预先在闭包中把X值存储起来</span><br><span class="line">return function(y)&#123;</span><br><span class="line">return x+y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(100)(200) */</span><br><span class="line">/* (function () &#123;</span><br><span class="line">//=&gt;this:需要改变THIS的函数</span><br><span class="line">//=&gt;context:需要改变的THIS指向</span><br><span class="line">//=&gt;outerArg:其余需要传递给函数的实参信息</span><br><span class="line">function myBind(context = window, ...outerArg) &#123;</span><br><span class="line">let _this = this; </span><br><span class="line">return function anonymous(...innerArg) &#123;</span><br><span class="line">_this.call(context, ...outerArg.concat(innerArg));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Function.prototype.myBind = myBind;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">name: &apos;OBJ&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function fn(...arg) &#123;</span><br><span class="line">console.log(this, arg);</span><br><span class="line">&#125;</span><br><span class="line">document.body.onclick = fn.myBind(obj, 100, 200);;</span><br><span class="line"> */</span><br><span class="line">//=&gt;点击的时候FN中的this=&gt;obj arg=&gt;[100,200,事件对象]</span><br><span class="line">// document.body.onclick = fn.bind(obj, 100, 200);</span><br><span class="line">// document.body.onclick = function (ev) &#123;</span><br><span class="line">// fn.call(obj, 100, 200, ev);</span><br><span class="line">// &#125;</span><br><span class="line">//=&gt;执行bind方法，会返回一个匿名函数，当事件触发，匿名函数执行，我们再处理fn即可</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// document.body.onclick = fn; //=&gt;this:BODY  arg:[事件对象]</span><br><span class="line">/* document.body.onclick = function (ev) &#123;</span><br><span class="line">//=&gt;ev事件对象：给元素的某个事件绑定方法，当事件触发会执行这个方法，并且会把当前事件的相关信息传递给这个函数“事件对象”</span><br><span class="line">console.log(ev);</span><br><span class="line">&#125; */</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript-——-面试题合集1&quot;&gt;&lt;a href=&quot;#JavaScript-——-面试题合集1&quot; class=&quot;headerlink&quot; title=&quot;JavaScript —— 面试题合集1&quot;&gt;&lt;/a&gt;JavaScript —— 面试题合集1&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="面试" scheme="https://wangyiye.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="指令" scheme="https://wangyiye.github.io/tags/%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Vue指令及基础知识</title>
    <link href="https://wangyiye.github.io/2019/03/26/Vue-%E6%8C%87%E4%BB%A4%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://wangyiye.github.io/2019/03/26/Vue-指令及基础知识/</id>
    <published>2019-03-26T03:48:49.000Z</published>
    <updated>2019-04-07T02:12:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h2><ul><li>数据驱动:<strong>操作DOM</strong></li><li>JS的数据类型 基本 和 引用</li><li>改变原数组 —&gt; 数组的变异 <strong>pop push shif unshift reverse sort splice(n,m,x,y,z)</strong></li><li>不改变原数组 —&gt; <strong>slice(n,m) concat indexOf join(‘+’) toString()</strong></li><li>数组的迭代方法 <ul><li>forEach </li><li>map:renturn什么值，就往新数组添加新属性，若没有return值，就添加undefined</li><li>filter<ul><li>1)filter的回调函数中return值，若是true，则把当前迭代的项复制一份到新数组arr中</li><li>2)filter的返回值是新数组arr</li></ul></li><li>some:<ul><li>1)回调函数中只要有一个回调函数返回的是true，则整个some 返回值就是ture</li><li>2)只要某个项满足条件，就不在进行迭代</li></ul></li><li>every:<ul><li>1)回调函数，每一个都是true，every的返回值才是true</li><li>2)换句话说就是只要有一个是false ，整个结果就是false</li></ul></li><li>reduce((prev,next)=&gt;):结果就是最后一次迭代的return值</li><li>find: 找到满足条件的第一项</li><li>includes(item,index)从index索引值开始查找 找到就是true 找不到就是false</li></ul></li></ul><h2 id="NODE基础命令"><a href="#NODE基础命令" class="headerlink" title="NODE基础命令"></a>NODE基础命令</h2><ul><li>package.json 是项目的依赖表单</li><li>dependencies:存储的都是生产环境的依赖</li><li>devdependencies:储存的都是开发环境的依赖</li><li>scripts:中存储的都是要执行的命令对应的代码</li><li>npm run hello : 对应的要执行hello对应的代码</li><li>npm i vue –save:在项目中添加依赖，安装依赖</li><li>npm i yarn -g : 全局安装yarn，以后可以使用yarn代替npm 去安装一些依赖</li></ul><h2 id="VUE-M-V-VM"><a href="#VUE-M-V-VM" class="headerlink" title="VUE - M-V-VM"></a>VUE - M-V-VM</h2><ul><li>1.vue 双向数据绑定 ；渐进式；框架</li><li>2.视图 V 数据 M  VM</li><li>3.视图改变 数据自动更新</li><li>4.数据更新 视图自动更改</li><li>5.渐进式: SPA 单页面开发<ul><li>核心:vue.js  </li><li>vue-router控制路由 </li><li>vuex 处理数据</li><li>axios 解决请求</li></ul></li></ul><h2 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h2><ul><li>编程式 forEach </li><li>声明式 for() 编程式</li></ul><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ul><li>框架:自己写的代码被框架调用 Vue React Angular BootStrap </li><li>库: 自己调用库的代码</li></ul><h2 id="Vue的指令"><a href="#Vue的指令" class="headerlink" title="Vue的指令"></a>Vue的指令</h2><ul><li>1.v-model: 是vue的指令 name是实例的变量 指令是指让对应的元素做某件事</li><li>2.v-text : 展示对应的文本</li><li>3.v-once : 对应的标签只渲染一次 1~3指令都是行内属性</li><li>4.v-html : 把值中的标签渲染出来</li><li>5.v-cloak : <strong>解决渲染闪烁问题</strong><pre><code>[v-cloak] {display: none;} &lt;div v-cloak&gt;{{ message }}&lt;/div&gt;</code></pre></li><li>6.v-show : 控制元素的display:ngone 属性</li><li>7.v-on:click : 给元素绑定事件 简写 <code>@click = &#39;fn&#39;</code></li><li>8.v-keyup.enter = ‘fn’ : 给元素绑定键盘事件</li><li>9.v-bind:绑定样式 对象 路径 缩写: <code>:</code></li><li>10.v-for : 循环显示元素的,可以循环数组，也可以循环<code>对象、字符串、数字</code> ，v-for优先级比v-if/else的优先级高，先渲染v-for</li><li>11.v-if / v-else-if /v-else :直接不加载元素,先做循环再做判断<h3 id="v-model指令"><a href="#v-model指令" class="headerlink" title="v-model指令"></a>v-model指令</h3></li><li><code>实现 数据和视图 双向绑定 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt;等表单元素和components组件</code></li><li>单个复选框，绑定到布尔值：  <input type="checkbox" id="checkbox" v-model="checked"></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;</span><br></pre></td></tr></table></figure><ul><li>CheckBox 多个复选框,绑定到同一个数组：<code>check = []</code><br>  <input type="checkbox" value="CSS" v-model="check"> CSS<br>  <input type="checkbox" value="HTML" v-model="check">HTML<br>  <input type="checkbox" value="JS" v-model="check">JS</li><li>check 若为 [] <code>一个数组</code>  则3个input框能联系在一起,选择input框，则会在数组中push表单框中的value值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">radio 单选框</span><br><span class="line">&lt;!-- 多个input绑定同一个变量即可 --&gt;</span><br><span class="line">&lt;input type=&quot;radio&quot; v-model=&quot;fruit&quot; value=&quot;1&quot;/&gt;🍎</span><br><span class="line">&lt;input type=&quot;radio&quot; v-model=&quot;fruit&quot; value=&quot;2&quot;/&gt;🍌</span><br><span class="line">&lt;input type=&quot;radio&quot; v-model=&quot;fruit&quot; value=&quot;3&quot;/&gt;🍊</span><br></pre></td></tr></table></figure><h2 id="v-model实现数据双向绑定的原理"><a href="#v-model实现数据双向绑定的原理" class="headerlink" title="v-model实现数据双向绑定的原理"></a>v-model实现数据双向绑定的原理</h2><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><ul><li>获取数据，当属性依赖于其他data中属性时，其他数据改变，才会触发这个方法，但必不会触发set方法</li><li>最终值是由get方法决定的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj,&apos;name&apos;,&#123;</span><br><span class="line">get()&#123;return 123&#125;,</span><br><span class="line">    set(val)&#123;</span><br><span class="line">        console.log(val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.name = 333;</span><br><span class="line">console.log(obj.name)</span><br></pre></td></tr></table></figure></li></ul><h4 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h4><ul><li>使用v-model:进行数据的双向绑定 只有点击改变值的时候，才会触发这个方法，触发这个方法必然触发了get方法</li><li><img src="/2019/03/26/Vue-指令及基础知识/3.png" alt="get与set的区别"></li></ul><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ul><li>self: 只有点击元素本身的时候才触发</li><li>stop:阻止冒泡</li><li>prevent:阻止默认事件</li><li>once: 对应的函数只触发一次</li><li>capture: 让事件在捕获阶段触发</li><li>passive : 优先执行默认事件，在执行绑定的函数，优化移动端性能，只对滚动行为有效<h3 id="v-model修饰符"><a href="#v-model修饰符" class="headerlink" title="v-model修饰符"></a>v-model修饰符</h3></li><li>number : 将字符串转化为数字 类似 parsefloat的效果</li><li>trim : 自动去除首尾空格</li></ul><h2 id="自定义全局键码"><a href="#自定义全局键码" class="headerlink" title="自定义全局键码"></a>自定义全局键码</h2><p><code>Vue.config.keyCodes.f2 = 113</code> =&gt; 在模板中可以这样使用 <code>@keyup.f2 = fn&#39;&#39;</code>·</p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;money | changeM&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>管道符前边是要处理的数据，后边是处理的参数，最终展示的是函数的返回值</li><li>过滤器是可以连续使用的，下一个过滤器的返回值，是上一个过滤器的返回值</li><li>全局过滤器和私有过滤器，全局过滤器任何组件都可以调用，私有过滤器只有定义过滤器的组件可以调用</li><li>filter 中的方法 可以重名，不会被冲掉，但尽可能不要重名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(&apos;过滤器名称&apos;，function()&#123;&#125;) 全局过滤器</span><br><span class="line">console.log(this) //=&gt; this 指向window</span><br><span class="line">在vm实例中定义</span><br><span class="line">filters:&#123;</span><br><span class="line">&apos;过滤器名称&apos;:functon()&#123;&#125;</span><br><span class="line">&#125; 私有过滤器</span><br></pre></td></tr></table></figure></li></ul><h2 id="侦听器-Watch"><a href="#侦听器-Watch" class="headerlink" title="侦听器 Watch"></a>侦听器 Watch</h2><ul><li>异步用监听,但是比较耗性能，能够深层监听，能够返回oldV 和 newV 两个值供实例调用</li><li>深层监听的属性必须是有set和get方法的属性值</li><li>当监听一个数组的时候，若数组地址不发生改变，那么不会触发watch的方法</li><li>Watch还可以监听到路由的变化</li><li>具有局限性，当监听的数据过多时，不适合使用watch方法</li></ul><h2 id="计算属性-Computed"><a href="#计算属性-Computed" class="headerlink" title="计算属性 Computed"></a>计算属性 Computed</h2><ul><li><p>同步用计算属性，但依赖性太强，用到get/set方法</p></li><li><p>定义的方法，挂载在vm的实例，不能跟methods和data重名，但是现在不报错，但是不能用，因为methods中的方法会把computed中的方法冲掉</p></li><li><p>只要name不发生改变，name2就不发生改变</p></li><li><p>name2用到谁，就依赖谁</p></li><li><p>conputed计算属性，具有缓存机制，若数据发生改变，会重新计算属性，若只是重复调用，则不会触发computed方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">name2()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name.split(<span class="string">''</span>).rerverse().join(<span class="string">''</span>)</span><br><span class="line">&#125;,</span><br><span class="line">name3()&#123;</span><br><span class="line"><span class="keyword">get</span>()&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line"><span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">set</span>(val)&#123;</span><br><span class="line"><span class="comment">// 给name3赋值的时候会触发, set函数</span></span><br><span class="line"><span class="comment">// val 是外界</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>computed / watch / methods 三者的区别</p><ul><li><code>computed</code> : 属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算，主要当做属性来使用</li><li><code>watch</code> : 一个对象，键是需要观察的表达式，值是对应的回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，可以看作是<code>methods</code>和<code>computed</code>的结合体</li><li><code>methods</code> : 表示一个具体的操作，主要书写业务逻辑<h2 id="自定义全局指令"><a href="#自定义全局指令" class="headerlink" title="自定义全局指令"></a>自定义全局指令</h2></li></ul></li><li><p>使用directive定义全局的指令</p></li><li><p>其中参数1：指令的名称，注意，在定义的时候，指令的名称前面，不需要加 -v 前缀</p></li><li><p>但是在调用的时候，必须在指令名称前加上 v- 前缀 进行调用</p></li><li><p>参数2：是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'focus'</span>,&#123;</span><br><span class="line">bind:<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;  =&gt;每当指令绑定到元素身上的时候，会立即执行这个bind函数，只执行一次</span><br><span class="line"><span class="comment">//1.注意：在每个函数中，第一个参数永远是el，表示被绑定的那个元素，这个el参数以一个原生JS对象</span></span><br><span class="line"><span class="comment">//2.在元素刚绑定指令的时候，还没有插入到DOM中，这时候，调用focus方法没有起作用</span></span><br><span class="line"><span class="comment">//3.因为，一个元素只有插入到DOM中，才能获取焦点</span></span><br><span class="line"><span class="comment">//el.focus()</span></span><br><span class="line">&#125;,</span><br><span class="line">inserted:<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;  =&gt;表示元素被插入到DOM中的时候，触发这个inserted函数，触发一次</span><br><span class="line">el.focus()</span><br><span class="line">&#125;,</span><br><span class="line">updated:<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;  =&gt;每当VNode更新的时候，会执行updated函数，可能会被触发多次 </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>自定义指令简写:<pre><code class="Vue.directive(&#39;focus&#39;,function(el,binding){})"></code></pre></li><li>钩子函数的参数:<ul><li>指令钩子函数会被传入以下实参</li><li>1.el : 指令所绑定的元素，可以用来直接操作 DOM </li><li>2.binding:<ul><li>name: 指令名，<code>不包括 v- 前缀</code>;</li><li>value:指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 <code>2</code>;</li><li>expression:字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 <code>&quot;1 + 1&quot;</code></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;VUE&quot;&gt;&lt;a href=&quot;#VUE&quot; class=&quot;headerlink&quot; title=&quot;VUE&quot;&gt;&lt;/a&gt;VUE&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数据驱动:&lt;strong&gt;操作DOM&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;JS的数据类型 基本 和 引用&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="Vue" scheme="https://wangyiye.github.io/categories/Vue/"/>
    
    
      <category term="指令" scheme="https://wangyiye.github.io/tags/%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
</feed>
