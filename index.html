<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="yiYe's Blog" type="application/atom+xml">






<meta name="description" content="一土一业">
<meta name="keywords" content="yiYe">
<meta property="og:type" content="website">
<meta property="og:title" content="yiYe&#39;s Blog">
<meta property="og:url" content="https://wangyiye.github.io/index.html">
<meta property="og:site_name" content="yiYe&#39;s Blog">
<meta property="og:description" content="一土一业">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yiYe&#39;s Blog">
<meta name="twitter:description" content="一土一业">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://wangyiye.github.io/">





  <title>yiYe's Blog</title>
  









  <script>
class Circle {
    //创建对象
    //以一个圆为对象
    //设置随机的 x，y坐标，r半径，_mx，_my移动的距离
    //this.r是创建圆的半径，参数越大半径越大
    //this._mx,this._my是移动的距离，参数越大移动
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.r = Math.random() * 10 ;
        this._mx = Math.random() ;
        this._my = Math.random() ;

    }

    //canvas 画圆和画直线
    //画圆就是正常的用canvas画一个圆
    //画直线是两个圆连线，为了避免直线过多，给圆圈距离设置了一个值，距离很远的圆圈，就不做连线处理
    drawCircle(ctx) {
        ctx.beginPath();
        //arc() 方法使用一个中心点和半径，为一个画布的当前子路径添加一条弧。
        ctx.arc(this.x, this.y, this.r, 0, 360)
        ctx.closePath();
        ctx.fillStyle = 'rgba(204, 204, 204, 0.3)';
        ctx.fill();
    }

    drawLine(ctx, _circle) {
        let dx = this.x - _circle.x;
        let dy = this.y - _circle.y;
        let d = Math.sqrt(dx * dx + dy * dy)
        if (d < 150) {
            ctx.beginPath();
            //开始一条路径，移动到位置 this.x,this.y。创建到达位置 _circle.x,_circle.y 的一条线：
            ctx.moveTo(this.x, this.y);   //起始点
            ctx.lineTo(_circle.x, _circle.y);   //终点
            ctx.closePath();
            ctx.strokeStyle = 'rgba(204, 204, 204, 0.3)';
            ctx.stroke();
        }
    }

    // 圆圈移动
    // 圆圈移动的距离必须在屏幕范围内
    move(w, h) {
        this._mx = (this.x < w && this.x > 0) ? this._mx : (-this._mx);
        this._my = (this.y < h && this.y > 0) ? this._my : (-this._my);
        this.x += this._mx / 2;
        this.y += this._my / 2;
    }
}
//鼠标点画圆闪烁变动
class currentCirle extends Circle {
    constructor(x, y) {
        super(x, y)
    }

    drawCircle(ctx) {
        ctx.beginPath();
        //注释内容为鼠标焦点的地方圆圈半径变化
        //this.r = (this.r < 14 && this.r > 1) ? this.r + (Math.random() * 2 - 1) : 2;
        this.r = 8;
        ctx.arc(this.x, this.y, this.r, 0, 360);
        ctx.closePath();
        //ctx.fillStyle = 'rgba(0,0,0,' + (parseInt(Math.random() * 100) / 100) + ')'
        ctx.fillStyle = 'rgba(255, 77, 54, 0.3)'
        ctx.fill();

    }
}
//更新页面用requestAnimationFrame替代setTimeout
window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;

let canvas = document.getElementById('canvas');
let ctx = canvas.getContext('2d');
let w = canvas.width = canvas.offsetWidth;
let h = canvas.height = canvas.offsetHeight;
let circles = [];
let current_circle = new currentCirle(0, 0)

let draw = function () {
    ctx.clearRect(0, 0, w, h);
    for (let i = 0; i < circles.length; i++) {
        circles[i].move(w, h);
        circles[i].drawCircle(ctx);
        for (j = i + 1; j < circles.length; j++) {
            circles[i].drawLine(ctx, circles[j])
        }
    }
    if (current_circle.x) {
        current_circle.drawCircle(ctx);
        for (var k = 1; k < circles.length; k++) {
            current_circle.drawLine(ctx, circles[k])
        }
    }
    requestAnimationFrame(draw)
}

let init = function (num) {
    for (var i = 0; i < num; i++) {
        circles.push(new Circle(Math.random() * w, Math.random() * h));
    }
    draw();
}
window.addEventListener('load', init(60));
window.onmousemove = function (e) {
    e = e || window.event;
    current_circle.x = e.clientX;
    current_circle.y = e.clientY;
}
window.onmouseout = function () {
    current_circle.x = null;
    current_circle.y = null;

};
</script>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>


    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">yiYe's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">YOU'VE MADE A BRAVE DECISION, WELCOME.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangyiye.github.io/2019/09/10/JavaScript What’s new in ES2019/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiYe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yiYe's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/10/JavaScript What’s new in ES2019/" itemprop="url">JavaScript What’s new in ES2019</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-10T18:51:32+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2019/09/10/JavaScript What’s new in ES2019/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::https://wangyiye.github.io/2019/09/10/JavaScript What’s new in ES2019/" class="cy_cmt_count" data-xid="2019/09/10/JavaScript What’s new in ES2019/" itemprop="commentsCount"></span>
                </a>
              
            
          

          
          
             <span id="/2019/09/10/JavaScript What’s new in ES2019/" class="leancloud_visitors" data-flag-title="JavaScript What’s new in ES2019">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  768
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </span></div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">


      
      

      
        
          
            <h2 id="JavaScript-What’s-new-in-ES2019"><a href="#JavaScript-What’s-new-in-ES2019" class="headerlink" title="JavaScript What’s new in ES2019"></a>JavaScript What’s new in ES2019</h2><p><img src="https://blog.tildeloop.com/media/javascript-es-2019.png" alt="Image text"></p>
<h3 id="Array-flat"><a href="#Array-flat" class="headerlink" title="Array.flat()"></a>Array.flat()</h3><p>现在可以递归地将嵌套数组扁平化到指定的深度。默认值是1，如果你想完全深入使用无穷大。该方法不修改原始数组，而是创建一个新的数组:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [1, 2, [3, 4]];</span><br><span class="line">arr1.flat(); // [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">const arr2 = [1, 2, [3, 4, [5, 6]]];</span><br><span class="line">arr2.flat(2); // [1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">const arr3 = [1, 2, [3, 4, [5, 6, [7, 8]]]];</span><br><span class="line">arr3.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure>

<p>如果你的数组中有一个空槽，它将被删除:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr4 = [1, 2, , 4, 5];</span><br><span class="line">arr4.flat(); // [1, 2, 4, 5]</span><br></pre></td></tr></table></figure>

<h3 id="Array-flatMap"><a href="#Array-flatMap" class="headerlink" title="Array.flatMap()"></a>Array.flatMap()</h3><p>一个新的方法，结合了基本的map函数，然后使用新的Array.flat()方法将结果扁平化到1的深度:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">arr1.map(x =&gt; [x * 4]); // [[4], [8], [12]]</span><br><span class="line">arr1.flatMap(x =&gt; [x * 4]); // [4, 8, 12]</span><br></pre></td></tr></table></figure>

<p>另一个更有用的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const sentence = [&quot;This is a&quot;, &quot;regular&quot;, &quot;sentence&quot;];</span><br><span class="line"></span><br><span class="line">sentence.map(x =&gt; x.split(&quot; &quot;)); // [[&quot;This&quot;,&quot;is&quot;,&quot;a&quot;],[&quot;regular&quot;],[&quot;sentence&quot;]]</span><br><span class="line">sentence.flatMap(x =&gt; x.split(&quot; &quot;)); // [&quot;This&quot;,&quot;is&quot;,&quot;a&quot;,&quot;regular&quot;, &quot;sentence&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="String-trimStart-and-String-trimEnd"><a href="#String-trimStart-and-String-trimEnd" class="headerlink" title="String.trimStart() and String.trimEnd()"></a>String.trimStart() and String.trimEnd()</h3><p>除了string . trim()删除字符串两边的空格外，现在还有单独的方法只删除字符串两边的空格:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const test = &quot; hello &quot;;</span><br><span class="line"></span><br><span class="line">test.trim(); // &quot;hello&quot;;</span><br><span class="line">test.trimStart(); // &quot;hello &quot;;</span><br><span class="line">test.trimEnd(); // &quot; hello&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h3><p>将键值对列表转换为对象的新方法。它执行与已经熟悉的函数对象相反的操作。将对象转换为数组时使用的项，以便更容易地进行操作。在转换之后，您将得到一个数组，但是现在您可以将操作后的数组返回到一个对象中。让我们试着用一个例子，我们想平方所有对象属性的值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; prop1: 2, prop2: 10, prop3: 15 &#125;;</span><br><span class="line"></span><br><span class="line">let array = Object.entries(obj); // [[&quot;prop1&quot;, 2], [&quot;prop2&quot;, 10], [&quot;prop3&quot;, 15]]</span><br></pre></td></tr></table></figure>

<p>让我们用一个简单的映射将键值对的新列表的值平方:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array = array.map(([key, value]) =&gt; [key, Math.pow(value, 2)]); // [[&quot;prop1&quot;, 4], [&quot;prop2&quot;, 100], [&quot;prop3&quot;, 225]]</span><br></pre></td></tr></table></figure>

<p>我们已经转换了对象值，但我们只剩下一个数组，这就是object . fromentries的作用，它将数组转换回一个对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const newObj = Object.fromEntries(array); // &#123;prop1: 4, prop2: 100, prop3: 225&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Optional-Catch-Binding"><a href="#Optional-Catch-Binding" class="headerlink" title="Optional Catch Binding"></a>Optional Catch Binding</h3><p>新提案允许您完全省略catch()参数，因为在很多情况下，您不希望使用它:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125; catch (er) &#123;</span><br><span class="line">  //handle error with parameter er</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">  //handle error without parameter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Symbol-description"><a href="#Symbol-description" class="headerlink" title="Symbol.description"></a>Symbol.description</h3><p>您现在可以访问符号的description属性，而不是使用toString()方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const testSymbol = Symbol(&quot;Desc&quot;);</span><br><span class="line"></span><br><span class="line">testSymbol.description; // &quot;Desc&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Function-toString"><a href="#Function-toString" class="headerlink" title="Function.toString()"></a>Function.toString()</h3><p>现在，对函数调用toString()将返回函数的定义，包括空格和注释。之前我们有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function /* foo comment */ foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">foo.toString(); // &quot;function foo() &#123;&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>And now it’s:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo.toString(); // &quot;function /* foo comment */ foo() &#123;&#125;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="JSON-parse-的改进"><a href="#JSON-parse-的改进" class="headerlink" title="JSON.parse()的改进"></a>JSON.parse()的改进</h3><p>行分隔符(\u2028)和段落分隔符(\u2029)符号现在可以正确解析，而不会导致SyntaxError。</p>
<p>翻译自 <a href="https://blog.tildeloop.com/posts/javascript-what%E2%80%99s-new-in-es2019" target="_blank" rel="noopener">https://blog.tildeloop.com/posts/javascript-what%E2%80%99s-new-in-es2019</a></p>

          
        
      
    </div>
    
    
    



    
    <div>
    

    



    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </div></article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangyiye.github.io/2019/09/09/浏览器渲染的重排与重绘/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiYe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yiYe's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/09/浏览器渲染的重排与重绘/" itemprop="url">前端性能优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-09T23:51:32+08:00">
                2019-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2019/09/09/浏览器渲染的重排与重绘/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::https://wangyiye.github.io/2019/09/09/浏览器渲染的重排与重绘/" class="cy_cmt_count" data-xid="2019/09/09/浏览器渲染的重排与重绘/" itemprop="commentsCount"></span>
                </a>
              
            
          

          
          
             <span id="/2019/09/09/浏览器渲染的重排与重绘/" class="leancloud_visitors" data-flag-title="前端性能优化">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  18
                </span>
              
            </div>
          

          

        </span></div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">


      
      

      
        
          
            <h2 id="细说浏览器渲染的重排与重绘"><a href="#细说浏览器渲染的重排与重绘" class="headerlink" title="细说浏览器渲染的重排与重绘"></a>细说浏览器渲染的重排与重绘</h2><blockquote>
<p>前端性能优化因为涉及到计算机网络、数据算法、图形图像处理、浏览器渲染等多方面计算机知识，常作为前端工程师乐此不疲的技术讨论话题，也正因如此，它也是面试时容易被问及的面试题之一。</p>
</blockquote>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><ul>
<li><p>URL从输入到页面展示的过程</p>
</li>
<li><p>DOM和JavaScript的关系</p>
</li>
<li><p>为什么操作DOM会很“慢”</p>
</li>
<li><p>浏览器解析HTML的过程</p>
</li>
<li><p>重排</p>
</li>
<li><p>重绘</p>
</li>
<li><p>优化方案</p>
<h3 id="URL从输入到页面展示的过程"><a href="#URL从输入到页面展示的过程" class="headerlink" title="URL从输入到页面展示的过程"></a>URL从输入到页面展示的过程</h3><p>在探讨浏览器解析html之前，先了解url从输入到最后页面渲染的过程是一个很有必要的步骤，它可以帮助我们把握整体流程，让我们在了解HTML解析细节之前知道它处于整个请求周期中的哪一阶段，这对我们构建完善知识图谱很有帮助。</p>
</li>
</ul>
<p>首先，我们假设输入的url的请求为最简单的Http请求，以GET请求为例，大致分以下几个步骤：</p>
<h5 id="1-用户在浏览器的地址栏输入访问的URL地址。浏览器会先根据这个URL查看浏览器缓存-系统缓存-路由器缓存，若缓存中有，直接跳到第6步操作，若没有，则按照下面的步骤进行操作。"><a href="#1-用户在浏览器的地址栏输入访问的URL地址。浏览器会先根据这个URL查看浏览器缓存-系统缓存-路由器缓存，若缓存中有，直接跳到第6步操作，若没有，则按照下面的步骤进行操作。" class="headerlink" title="1. 用户在浏览器的地址栏输入访问的URL地址。浏览器会先根据这个URL查看浏览器缓存-系统缓存-路由器缓存，若缓存中有，直接跳到第6步操作，若没有，则按照下面的步骤进行操作。"></a>1. 用户在浏览器的地址栏输入访问的URL地址。浏览器会先根据这个URL查看浏览器缓存-系统缓存-路由器缓存，若缓存中有，直接跳到第6步操作，若没有，则按照下面的步骤进行操作。</h5><h5 id="2-浏览器根据输入的URL地址解析出主机名。"><a href="#2-浏览器根据输入的URL地址解析出主机名。" class="headerlink" title="2. 浏览器根据输入的URL地址解析出主机名。"></a>2. 浏览器根据输入的URL地址解析出主机名。</h5><pre><code>&gt;  URI（Uniform Resource Identifier / 统一资源标志符）  包含url和urn
URL（Uniform Resource Locator / 统一资源定位符）
URN（Uniform Resource Name / 统一资源名称）国际统一发版编号（使用率极低）
URL    https://mbd.baidu.com:80/newspage/data/landingsuper?context=%7B&quot;nid&quot;%3A&quot;news_9461431018812454469&quot;%7D&amp;n_type=0&amp;p_from=1#ee23</code></pre><ul>
<li>协议 http://    <ul>
<li>能够把客户端和服务器端通信的信息进行传输的工具<ul>
<li>HTTP 超文本传输协议</li>
<li>HTTPS 为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密</li>
<li>FTP 文件传输协议（应用于资源的下载和上传）</li>
</ul>
</li>
</ul>
</li>
<li>域名：mbd.baidu.com：一个让用户方便记忆的名称（不通过域名，直接用服务器的外网ip）（.com /.cn/.com.cn/.edu/.io/.gov/.org/.net<ul>
<li>顶级域名 baidu.com</li>
<li><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 1级域名</li>
<li>music.baidu.com 2级域名</li>
<li>kbs.music..baidu.com 3级域名</li>
</ul>
</li>
<li>端口号：  :80  (0-65535) <ul>
<li>用端口号区分同一台服务器上不同的项目,如果项目采用的就是默认端口号，书写地址可以不用加端口号，浏览器再发送请求的时候会默认添加端口号。<ul>
<li>http 80</li>
<li>https 443</li>
<li>ftp 21</li>
</ul>
</li>
</ul>
</li>
<li>请求资源路径名称：/newspage/data/landingsuper<ul>
<li>默认路径或名称  xxx.com/ 没写路径的话找默认资源，可以在服务器自己配置一般默认资源名称default.html </li>
<li>伪URL地址处理（URL重写为了增加seo搜索引擎优化，动态的网址一般不会被搜索引擎收录，所以我们把动态的网址静态化，需要重写url</li>
</ul>
</li>
<li>问号传参信息:  ?context=%7B”nid”%3A”news_9461431018812454469”%7D&amp;n_type=0&amp;p_from=1<ul>
<li>客户端把信息传递给服务器方式<ul>
<li>url地址问号传参</li>
<li>请求报文传输</li>
</ul>
</li>
<li>实现不同页面之间的信息交互 列表到详情</li>
</ul>
</li>
<li>HASH值 #ee23<ul>
<li>信息传输</li>
<li>锚点定位</li>
<li>基于HASH实现路由管控，不同的HASH值展示不同的组件和模块。</li>
</ul>
</li>
</ul>
<p>请求的地址中如果出现UNICODE编码内容，现代版浏览器会默认的进行编码<br>    1. 基于encodeURI编码，我们可以基于decodeURI解码，编码的是整个URL，这样整个URL中的特殊字符都会自动编译，<br>    2. encodeURIComponent/decodeURIComponent,是对URL的部分信息编码，一般是？后的信息编码。客户端和服务器端进行信息传输的时候，如果需要把请求的信息编码，要基于这两种赋值，进行统一编码解码。<br>    3. 客户端还存在针对中文的编码方式escape/unescape  后台不一定有，一般应用于客户端页面之间自己的处理。例如从列表跳转到详情，可以把传递的中文信息基于这个编码，详情页面获取编码后的信息再解码。各种客户端中的cookie信息，如果信息是中文，我们也基于这种办法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> //=&gt;基于JS实现页面跳转</span><br><span class="line">link.onclick = function () &#123;</span><br><span class="line">	//=&gt;获取当前页面的URL地址</span><br><span class="line">	let url = window.location.href;</span><br><span class="line">	//=&gt;跳转页面</span><br><span class="line">	window.location.href = &quot;http://www.zhufengpeixun.cn/stu/?from=&quot; + encodeURIComponent(url);</span><br><span class="line">	// window.open(&quot;http://www.zhufengpeixun.cn/&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-浏览器将主机名转换成服务器ip地址。浏览器先查找本地DNS缓存列表，看缓存里面是否存在这个ip-如果有则进入第4步，如果缓存中不存在这个ip地址，就再向浏览器默认的DNS服务器发送查询请求，同时缓存当前这个ip到DNS缓存列表中。更详细步骤参考https-www-cnblogs-com-xsilence-p-6035559-html"><a href="#3-浏览器将主机名转换成服务器ip地址。浏览器先查找本地DNS缓存列表，看缓存里面是否存在这个ip-如果有则进入第4步，如果缓存中不存在这个ip地址，就再向浏览器默认的DNS服务器发送查询请求，同时缓存当前这个ip到DNS缓存列表中。更详细步骤参考https-www-cnblogs-com-xsilence-p-6035559-html" class="headerlink" title="3. 浏览器将主机名转换成服务器ip地址。浏览器先查找本地DNS缓存列表，看缓存里面是否存在这个ip,如果有则进入第4步，如果缓存中不存在这个ip地址，就再向浏览器默认的DNS服务器发送查询请求，同时缓存当前这个ip到DNS缓存列表中。更详细步骤参考https://www.cnblogs.com/xsilence/p/6035559.html"></a>3. 浏览器将主机名转换成服务器ip地址。浏览器先查找本地DNS缓存列表，看缓存里面是否存在这个ip,如果有则进入第4步，如果缓存中不存在这个ip地址，就再向浏览器默认的DNS服务器发送查询请求，同时缓存当前这个ip到DNS缓存列表中。更详细步骤参考<a href="https://www.cnblogs.com/xsilence/p/6035559.html" target="_blank" rel="noopener">https://www.cnblogs.com/xsilence/p/6035559.html</a></h5><blockquote>
<p>在服务器上存储着  域名 –服务器外网IP ,对DNS发送请求，进行DNS解析过程即：根据域名，在DNS服务器上查找到对应服务器的外网IP</p>
</blockquote>
<p>DNS优化</p>
<ul>
<li>缓存 浏览器会在第一次解析后，默认建立缓存，时间为1min</li>
<li>减少DNS解析次数，一个网站中我们需要发送请求的域名和服务器尽可能减少</li>
<li>DNS预获取，dns-prefetch: 在页面加载开始的时候，就把当前页面中需要访问其他域名（服务器）的信息进行提前dns解析，以后加载到具体内容部分可以不用解析。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//static.360buyimg.com&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//misc.360buyimg.com&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img10.360buyimg.com&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img11.360buyimg.com&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img12.360buyimg.com&quot;&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="4-拿到ip地址后，浏览器再从URL中解析出端口号。"><a href="#4-拿到ip地址后，浏览器再从URL中解析出端口号。" class="headerlink" title="4. 拿到ip地址后，浏览器再从URL中解析出端口号。"></a>4. 拿到ip地址后，浏览器再从URL中解析出端口号。</h5><h5 id="5-拿到ip和端口后，浏览器会建立一条与目标Web服务器的TCP连接，也就是传说中的三次握手。"><a href="#5-拿到ip和端口后，浏览器会建立一条与目标Web服务器的TCP连接，也就是传说中的三次握手。" class="headerlink" title="5. 拿到ip和端口后，浏览器会建立一条与目标Web服务器的TCP连接，也就是传说中的三次握手。"></a>5. 拿到ip和端口后，浏览器会建立一条与目标Web服务器的TCP连接，也就是传说中的三次握手。</h5><p><img src="./img/8.png" alt="Image text"></p>
<ul>
<li>第一次握手：由浏览器发起，告诉服务器我要发送请求了</li>
<li>第二次握手：由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧</li>
<li>第三次握手：由浏览器发送，告诉服务器，我马上就发了，准备接受吧</li>
</ul>
<h5 id="6-浏览器向服务器发送一条HTTP请求报文。"><a href="#6-浏览器向服务器发送一条HTTP请求报文。" class="headerlink" title="6. 浏览器向服务器发送一条HTTP请求报文。"></a>6. 浏览器向服务器发送一条HTTP请求报文。</h5><h5 id="7-服务器向浏览器返回一条HTTP响应报文。"><a href="#7-服务器向浏览器返回一条HTTP响应报文。" class="headerlink" title="7. 服务器向浏览器返回一条HTTP响应报文。"></a>7. 服务器向浏览器返回一条HTTP响应报文。</h5><ul>
<li><p>HTTP报文：请求报文+响应报文</p>
</li>
<li><p>请求报文 ：所有经过传输协议，客户端传递给服务器的内容<br><img src="./img/11.png" alt="Image text"></p>
<ul>
<li>起始行</li>
<li>请求首部</li>
<li>请求主体<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>响应报文：所有经过传输协议，服务器返回给客户端的内容<br><img src="./img/10.png" alt="Image text"></p>
<ul>
<li>HTTP状态码的信息</li>
<li>响应首部</li>
<li>相应主体</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;version&gt;&lt;status&gt;&lt;reason-phrase&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure>

<p>HTTP状态码</p>
<blockquote>
<p>1-5开头三位数字</p>
</blockquote>
<ul>
<li>200 OK</li>
<li>201 created一般应用于告诉服务器创建一个新文件，服务器创建成功后返回的状态码</li>
<li>204 NO Content 对于某些请求 put delete 请求，服务器拒绝请求，返回空内容，并且以状态码204告知。</li>
<li>301 Moved Permanently  永久重定向（永久转移） </li>
<li>302 Moved Temporarily  临时转移，现在用307处理，临时重定向Temporary Redirect  主要应用于负载均衡。</li>
<li>304 NOT Modified 设置HTTP的协商缓存 </li>
<li>400 Bad Request    传递给服务器的 参数错误</li>
<li>401 Unauthorized  无权限访问</li>
<li>404 Not Found  请求地址错误</li>
<li>500  Internal Server Error未知服务器错误</li>
<li>503 Service Unavailable 服务器超负荷</li>
</ul>
<h5 id="8-关闭连接-浏览器解析文档。"><a href="#8-关闭连接-浏览器解析文档。" class="headerlink" title="8. 关闭连接 浏览器解析文档。"></a>8. 关闭连接 浏览器解析文档。</h5><p><img src="/img/12.jpg" alt="Image text">)</p>
<ul>
<li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li>
<li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li>
<li>Layout(回流): 根据生成的渲染树，计算它们在设备视口(viewport)内的确切位置和大小，这个阶段是回流</li>
<li>Painting(重绘): 根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li>
<li>Display:将像素发送给GPU，展示在页面上</li>
</ul>
<h5 id="9-如果文档中有资源则重复6、7、8动作，直至资源全部加载完毕。"><a href="#9-如果文档中有资源则重复6、7、8动作，直至资源全部加载完毕。" class="headerlink" title="9. 如果文档中有资源则重复6、7、8动作，直至资源全部加载完毕。"></a>9. 如果文档中有资源则重复6、7、8动作，直至资源全部加载完毕。</h5><h5 id="10-4次挥手"><a href="#10-4次挥手" class="headerlink" title="10 4次挥手"></a>10 4次挥手</h5><p><img src="./img/9.png" alt="Image text"></p>
<ul>
<li>第一次挥手：由浏览器发起，发送给服务器，我请求报文发送完了，你准备关闭吧；</li>
<li>第二次挥手：由服务器发起，告诉浏览器，我接收完请求报文，我准备关闭，你也准备吧；</li>
<li>第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完毕，你准备关闭吧；</li>
<li>第四次挥手：由浏览器发起，告诉服务器，我响应报文接收完毕，我准备关闭，你也准备吧；</li>
</ul>
<blockquote>
<p>实际上在http请求方式不同、有无代理、有无负载均衡等不同场景下访问服务器的细节流程也会有一些差别，但这并不影响我们对整个访问环节的理解</p>
</blockquote>
<h3 id="DOM和JavaScript的关系"><a href="#DOM和JavaScript的关系" class="headerlink" title="DOM和JavaScript的关系"></a>DOM和JavaScript的关系</h3><p>文档对象模型（DOM）是一个独立于语言，用于操作XML和HTML文档的API,在web端，我们常用来操作HTML，但其实DOM也是可以操作XML文档的。</p>
<p>我们现在知道，DOM是一个独立于语言的API，换句话说，DOM是一个与语言无关的API，别的语言也可以实现操作DOM的具体api，但是它在浏览器中是用JavaScript来实现的，也因此，DOM是现在JavaScript编码中很重要的一部分，因为JavaScript很多时候都在操作底层文档。</p>
<h3 id="为什么操作DOM会很慢"><a href="#为什么操作DOM会很慢" class="headerlink" title="为什么操作DOM会很慢"></a>为什么操作DOM会很慢</h3><p>虽然DOM是由JavaScript实现的，但是在浏览器中都是把DOM和JavaScript分开来实现的，比如IE中，JavaScript的实现名为JScript，放在jscript.dll文件中，而DOM则放在另一个叫做mshtml.dll的库中。在Safari中，DOM和渲染是使用Webkit中的WebCore实现，而JavaScript是由独立的JavaScriptCore引擎实现，同样在Chrome中，同样是使用WebCore来实现渲染，而JavaScript引擎则是他们自己研发的V8引擎。</p>
<p>由于DOM和JavaScript是被分开独立实现的，因此，每一次在通过js操作DOM的时候，就需要先去连接js和DOM，我们可以这样理解：把DOM和JavaScript比作两个岛，他们之间通过一个收费的桥连接着，每一次访问DOM的时候，就需要经过这座桥，并且给“过路费”，访问的次数越多，路费就会越高，并且访问到DOM后，操作具体的DOM还需要给“操作费”，由于浏览器访问DOM的操作很多，因此，“路费”和“操作费”自然会增加，这就是为什么操作DOM会很慢的原因</p>
<h3 id="浏览器渲染HTML的步骤"><a href="#浏览器渲染HTML的步骤" class="headerlink" title="浏览器渲染HTML的步骤"></a>浏览器渲染HTML的步骤</h3><p>HTML渲染大致分为如下几步：</p>
<ol>
<li><p>HTML被HTML解析器解析成DOM Tree, css则被css解析器解析成CSSOM Tree。</p>
</li>
<li><p>DOM Tree和CSSOM Tree解析完成后，被附加到一起，形成渲染树（Render Tree）。</p>
</li>
<li><p>节点信息计算(重排)，这个过程被叫做Layout(Webkit)或者Reflow(Mozilla)。即根据渲染树计算每个节点的几何信息。</p>
</li>
<li><p>渲染绘制(重绘)，这个过程被叫做(Painting 或者 Repaint)。即根据计算好的信息绘制整个页面。</p>
</li>
</ol>
<p>以上4步简述浏览器的一次渲染过程，理论上，每一次的dom更改或者css几何属性更改，都会引起一次浏览器的重排/重绘过程，而如果是css的非几何属性更改，则只会引起重绘过程。所以说重排一定会引起重绘，而重绘不一定会引起重排。</p>
<h3 id="重排（Relayout-Reflow）"><a href="#重排（Relayout-Reflow）" class="headerlink" title="重排（Relayout/Reflow）"></a>重排（Relayout/Reflow）</h3><p>在弄明白什么是重排之前，我们要知道：浏览器渲染页面默认采用的是流式布局模型（Flow Based Layout），这一点很重要。</p>
<p>所谓重排，实际上是根据渲染树中每个渲染对象的信息，计算出各自渲染对象的几何信息（DOM对象的位置和尺寸大小），并将其安置在界面中的正确位置。</p>
<p>由于浏览器渲染界面是基于流式布局模型的，也就是某一个DOM节点信息更改了，就需要对DOM结构进行重新计算，重新布局界面，再次引发回流，只是这个结构更改程度会决定周边DOM更改范围，即全局范围和局部范围，全局范围就是从根节点html开始对整个渲染树进行重新布局，例如当我们改变了窗口尺寸或方向或者是修改了根元素的尺寸或者字体大小等；而局部布局可以是对渲染树的某部分或某一个渲染对象进行重新布局。</p>
<h4 id="在此，总结会引起重排的操作有："><a href="#在此，总结会引起重排的操作有：" class="headerlink" title="在此，总结会引起重排的操作有："></a>在此，总结会引起重排的操作有：</h4><ol>
<li><p>页面首次渲染。</p>
</li>
<li><p>浏览器窗口大小发生改变。</p>
</li>
<li><p>元素尺寸或位置发生改变。</p>
</li>
<li><p>元素内容变化（文字数量或图片大小等等）。</p>
</li>
<li><p>元素字体大小变化。</p>
</li>
<li><p>添加或者删除可见的DOM元素。</p>
</li>
<li><p>激活CSS伪类（例如：:hover）。</p>
</li>
<li><p>设置style属性</p>
</li>
<li><p>查询某些属性或调用某些方法。</p>
</li>
</ol>
<blockquote>
<p>常见引起重排属性和方法<br>width    height    margin    padding<br>display    border    position    overflow<br>clientWidth    clientHeight    clientTop    clientLeft<br>offsetWidth    offsetHeight    offsetTop    offsetLeft<br>scrollWidth    scrollHeight    scrollTop    scrollLeft<br>scrollIntoView()    scrollTo()    getComputedStyle()<br>getBoundingClientRect()    scrollIntoViewIfNeeded()</p>
</blockquote>
<blockquote>
<p>重排也叫回流，实际上，reflow的字面意思也是回流，之所以有的叫做重排，也许是因为重排更好理解，更符合中国人的思维。标准文档之所以叫做回流（Reflow）,是因为浏览器渲染是基于“流式布局”的模型，流实际就使我们常说的文档流，当dom或者css几何属性发生改变的时候，文档流会受到波动联动的去更改，流就好比一条河里的水，回流就好比向河里扔了一块石头，激起涟漪，然后引起周边水流受到波及，所以叫做回流，这样理解似乎更标准更规范，不过叫什么并不重要，重要的是我们真正理解了这个过程便好。</p>
</blockquote>
<h3 id="重绘（Repainting）"><a href="#重绘（Repainting）" class="headerlink" title="重绘（Repainting）"></a>重绘（Repainting）</h3><p>相比重排，重绘就简单多了，所谓重绘，就是当页面中元素样式的改变并不影响它在文档流中的位置时，例如更改了字体颜色,浏览器会将新样式赋予给元素并重新绘制的过程称。</p>
<p>常见引起浏览器绘制过程的属性包含：</p>
<blockquote>
<p>color    border-style    visibility    background<br>text-decoration    background-image    background-position    background-repeat<br>outline-color    outline    outline-style    border-radius<br>outline-width    box-shadow    background-size</p>
</blockquote>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>我们知道操作DOM是一个高成本的操作，不仅是因为本身js与DOM的链接访问，还包括操作DOM后会引起一连串的连锁反应（重排），因此，从性能优化角度，我们可以从以下几个方面着手：</p>
<ul>
<li><p>减少DOM操作（放弃传统操作dom的时代，基于vue/react开始数据影响视图模式）</p>
<ul>
<li><p>最小化DOM访问次数，尽量缓存访问DOM的样式信息，避免过度触发回流。</p>
</li>
<li><p>如果在一个局部方法中需要多次访问同一个dom，则先暂存它的引用。</p>
</li>
</ul>
</li>
<li><p>分离读写操作 （现代的浏览器都有渲染队列的机制）</p>
</li>
<li><p>采用更优的API替代消费高的api，转换优化消费高的集合</p>
<ul>
<li><p>用querySelectorAll()替代getElementByXX()。</p>
</li>
<li><p>开启动画的GPU加速，把渲染计算交给GPU。</p>
</li>
<li><p>少用HTML集合（类数组）来遍历，因为集合遍历比真数组遍历耗费更高。</p>
</li>
<li><p>用事件委托来减少事件处理器的数量。</p>
</li>
</ul>
</li>
<li><p>减少重排</p>
<ul>
<li><p>样式集中改变</p>
</li>
<li><p>缓存布局信息</p>
</li>
<li><p>元素批量修改</p>
</li>
<li><p>避免设置大量的style属性，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow，所以最好是使用class属性</p>
</li>
<li><p>动画效果应用到position属性为absolute或fixed的元素上（脱离文档流）</p>
</li>
<li><p>动画实现的速度的选择。比如实现一个动画，以1个像素为单位移动这样最平滑，但是reflow就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多。</p>
</li>
<li><p>不要使用table布局，因为table中某个元素旦触发了reflow，那么整个table的元素都会触发reflow。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围</p>
</li>
</ul>
</li>
<li><p>css及动画处理</p>
<ul>
<li><p>少用css表达式</p>
</li>
<li><p>减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；</p>
</li>
<li><p>动画尽量使用在绝对定位或固定定位的元素上；</p>
</li>
<li><p>隐藏在屏幕外，或在页面滚动时，尽量停止动画；</p>
</li>
</ul>
</li>
<li><p>牺牲平滑度换取速度</p>
</li>
<li><p>避免table布局和使用css的javascript表达式</p>
</li>
</ul>
<h4 id="其他优化方案"><a href="#其他优化方案" class="headerlink" title="其他优化方案"></a>其他优化方案</h4><ol>
<li>减少HTTP请求次数和请求的大小</li>
</ol>
<ul>
<li>文件合并压缩</li>
<li>雪碧图 css sprite</li>
<li>图片base64</li>
<li>尽量使用字体图标</li>
<li>图片懒加载</li>
<li>音视频取消预加载</li>
<li>在客户端和服务器端进行信息交互的时候，对于多项数据我们尽可能基于JSON格式来进行传送（JSON格式的数据处理方便，资源偏小）</li>
<li>开启服务器端的gzip压缩<br>……</li>
</ul>
<ol start="2">
<li>建立缓存机制</li>
</ol>
<ul>
<li>DNS缓存</li>
<li>数据缓存（例如：本地存储）</li>
<li>强缓存 和 协商缓存（304）</li>
<li>离线存储</li>
<li>做CDN加速<br>……</li>
</ul>
<ol start="3">
<li>代码上的优化</li>
</ol>
<ul>
<li>减少DOM的重绘和回流</li>
<li>在JS中尽量减少闭包的使用</li>
<li>在JS中避免“嵌套循环”和“死循环”</li>
<li>尽可能使用事件委托</li>
<li>尽量减少CSS表达式的使用(expression)</li>
<li>CSS选择器解析规则是从右向左解析</li>
<li>页面中的数据获取采用异步编程和延迟分批加载</li>
<li>尽可能实现JS的封装（低耦合高内聚），减少页面中的冗余代码</li>
<li>尽量减少对于filter滤镜属性的使用</li>
<li>在CSS导入的时候尽量减少使用@import导入式</li>
<li>使用window.requestAnimationFrame（JS中的帧动画）代替传统的定时器动画</li>
<li>减少递归的使用，避免死递归，避免由于递归导致的栈内存嵌套</li>
<li>基于SCRIPT调取JS的时候，可已使用 defer或者async 来异步加载</li>
<li>避免使用with语句<br>……</li>
</ul>
<h3 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h3><p>本篇文章主要抓取url从输入到最后渲染成界面这一流程中的浏览器解析渲染HTML这一步骤来探讨前端优化的思路和原因，核心思想基于重排和重绘的关系来展开讨论，主题大致有如下几点：</p>
<ul>
<li><p>url从输入到最后渲染的大致环节。</p>
</li>
<li><p>重排一定会重绘，重绘不一定有重排。</p>
</li>
<li><p>Js操作DOM是一个高消费过程。</p>
</li>
<li><p>会引起重排/重绘的属性和方法列举</p>
</li>
<li><p>优化思路（减少dom操作、替换高性能api、暂存引用、减少重排、开启硬件加速等）。</p>
</li>
</ul>
<blockquote>
<p>感谢这个时代，让我们可以站在巨人的肩膀上，窥探程序世界的宏伟壮观，我愿以一颗赤子心，踏遍程序世界的千山万水！愿每一个行走在程序世界的同仁，都活成心中想要的样子，加油。</p>
</blockquote>
<p>引用文章：小白师兄 周啸天<br>链接：<a href="https://www.imooc.com/article/45936" target="_blank" rel="noopener">https://www.imooc.com/article/45936</a><br>链接：<a href="https://www.yuque.com/books/share/b09738d1-9059-4fb5-9581-95df9e85e2c6/wmu1u9" target="_blank" rel="noopener">https://www.yuque.com/books/share/b09738d1-9059-4fb5-9581-95df9e85e2c6/wmu1u9</a></p>

          
        
      
    </div>
    
    
    



    
    <div>
    

    



    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </div></article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangyiye.github.io/2018/09/08/原理题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiYe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yiYe's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/08/原理题/" itemprop="url">面试题JS题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-08T18:51:32+08:00">
                2018-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/09/08/原理题/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::https://wangyiye.github.io/2018/09/08/原理题/" class="cy_cmt_count" data-xid="2018/09/08/原理题/" itemprop="commentsCount"></span>
                </a>
              
            
          

          
          
             <span id="/2018/09/08/原理题/" class="leancloud_visitors" data-flag-title="面试题JS题">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  23
                </span>
              
            </div>
          

          

        </span></div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">


      
      

      
        
          
            <h2 id="JavaScript-——-面试题合集1"><a href="#JavaScript-——-面试题合集1" class="headerlink" title="JavaScript —— 面试题合集1"></a>JavaScript —— 面试题合集1</h2><h4 id="call-和-apply-的区别是什么，哪个性能更好一些"><a href="#call-和-apply-的区别是什么，哪个性能更好一些" class="headerlink" title="call 和 apply 的区别是什么，哪个性能更好一些"></a>call 和 apply 的区别是什么，哪个性能更好一些</h4><p>call的性能要比apply好一些，（传递给函数的参数超过三个的时候差距明显）后期开发过程中偏向使用call<br>性能检测的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.time(&apos;A&apos;);</span><br><span class="line">for(let i = 0;i&lt;9;i++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.timeEnd(&apos;A&apos;)</span><br></pre></td></tr></table></figure>

<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><ol>
<li>箭头函数语法上上普通函数更加简洁（ES6中的每一种函数都可以使用形参赋值和剩余运算符）iiiiiiiiiiiiiii</li>
<li>箭头函数没有this，他里面出现的this继承函数所处上下文中的this，使用call/apply等任何方式无法改变。</li>
<li>箭头函数没有ArgumentS（类数组）只能基于…arg获取传递的参数集合（数组）；</li>
<li>箭头函数不能被new执行（因为：箭头函数没有prototype也没有this）<h4 id="实现-5-add-3-minus-2-，使其输出结果为：6"><a href="#实现-5-add-3-minus-2-，使其输出结果为：6" class="headerlink" title="实现 (5).add(3).minus(2) ，使其输出结果为：6"></a>实现 (5).add(3).minus(2) ，使其输出结果为：6</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> ~ function () &#123;</span><br><span class="line">	//=&gt;每一个方法执行完，都要返回NUMBER这个类的实例，这样才可以继续调取NUMBER类原型中的方法（链式写法）</span><br><span class="line">	function check(n) &#123;</span><br><span class="line">		n = Number(n);</span><br><span class="line">		return isNaN(n) ? 0 : n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function add(n) &#123;</span><br><span class="line">		n = check(n);</span><br><span class="line">		return this + n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function minus(n) &#123;</span><br><span class="line">		n = check(n);</span><br><span class="line">		return this - n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Number.prototype.add = add;</span><br><span class="line">	Number.prototype.minus = minus;</span><br><span class="line">	//  [&quot;add&quot;, &quot;minus&quot;].forEach(item =&gt; &#123;</span><br><span class="line">	// 	Number.prototype[item] = eval(item);</span><br><span class="line">	// &#125;); </span><br><span class="line">&#125;();</span><br><span class="line">console.log((5).add(3).minus(2));</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//=&gt;回调函数：把一个函数B作为实参传递给另外一个函数A，函数A在执行的时候，可以把传递进来的函数B去执行（执行N次，可传值，可改THIS）</span><br><span class="line"> function each(arr, callBack) &#123;</span><br><span class="line">	//=&gt;callBack:function(item, index)&#123;&#125;</span><br><span class="line"> 	for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line"> 		let flag = callBack.call(arr, arr[i], i);</span><br><span class="line">		//=&gt;接受回调函数返回的结果，如果是FALSE，我们结束循环</span><br><span class="line">		if (flag === false) &#123;</span><br><span class="line"> 			break;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> each([10, 20, 30, 40], function (item, index) &#123;</span><br><span class="line">	//=&gt;this:原始操作数组</span><br><span class="line"> 	if (index &gt; 1) &#123;</span><br><span class="line"> 		return false;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="如何把一个字符串的大小写取反（大写变小写小写变大写），例如-’AbC’-变成-‘aBc’"><a href="#如何把一个字符串的大小写取反（大写变小写小写变大写），例如-’AbC’-变成-‘aBc’" class="headerlink" title="如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC’ 变成 ‘aBc’"></a>如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC’ 变成 ‘aBc’</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;zhufengPEIxun的周老师很帅！吁*100！HAHA&quot;;</span><br><span class="line">str = str.replace(/[a-zA-Z]/g, content =&gt; &#123;</span><br><span class="line">	//=&gt;content:每一次正则匹配的结果</span><br><span class="line">	//验证是否为大写字母：把字母转换为大写后看和之前是否一样，如果一样，之前也是大写的；在ASCII表中找到大写字母的取值范围进行判断（65-90）；</span><br><span class="line">	// content.toUpperCase()===content</span><br><span class="line">	// content.charCodeAt()&gt;=65 &amp;&amp; content.charCodeAt()&lt;=90</span><br><span class="line">	return content.toUpperCase() === content ? content.toLowerCase() : content.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line">console.log(str);</span><br></pre></td></tr></table></figure>

<h4 id="实现一个字符串匹配算法，从字符串-S-中，查找是否存在字符串-T，若存在返回所在位置，不存在返回-1！（如果不能基于indexOf-includes等内置的方法，你会如何处理呢？）"><a href="#实现一个字符串匹配算法，从字符串-S-中，查找是否存在字符串-T，若存在返回所在位置，不存在返回-1！（如果不能基于indexOf-includes等内置的方法，你会如何处理呢？）" class="headerlink" title="实现一个字符串匹配算法，从字符串 S 中，查找是否存在字符串 T，若存在返回所在位置，不存在返回-1！（如果不能基于indexOf/includes等内置的方法，你会如何处理呢？）"></a>实现一个字符串匹配算法，从字符串 S 中，查找是否存在字符串 T，若存在返回所在位置，不存在返回-1！（如果不能基于indexOf/includes等内置的方法，你会如何处理呢？）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">~ function () &#123;</span><br><span class="line">	/*</span><br><span class="line">	 * 循环原始字符串中的每一项，让每一项从当前位置向后截取T.length个字符，然后和T进行比较，如果不一样，继续循环；如果一样返回当前索引即可（循环结束）；</span><br><span class="line">	 */</span><br><span class="line">	function myIndexOf(T) &#123;</span><br><span class="line">		//=&gt;THIS:S</span><br><span class="line">		let lenT = T.length,</span><br><span class="line">			lenS = this.length,</span><br><span class="line">			res = -1;</span><br><span class="line">		if (lenT &gt; lenS) return -1;</span><br><span class="line">		for (let i = 0; i &lt;= lenS - lenT; i++) &#123;</span><br><span class="line">			if (this.substr(i, lenT) === T) &#123;</span><br><span class="line">				res = i;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * 正则处理 </span><br><span class="line">	 */</span><br><span class="line">	function myIndexOf(T) &#123;</span><br><span class="line">		//=&gt;THIS:S</span><br><span class="line">		let reg = new RegExp(T),</span><br><span class="line">			res = reg.exec(this);</span><br><span class="line">		return res === null ? -1 : res.index;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	String.prototype.myIndexOf = myIndexOf;</span><br><span class="line">&#125;();</span><br><span class="line">// let S = &quot;zhufengpeixun&quot;,</span><br><span class="line">// 	T = &quot;pei&quot;;</span><br><span class="line">// console.log(S.myIndexOf(T));</span><br></pre></td></tr></table></figure>

<h4 id="输出下面代码运行结果"><a href="#输出下面代码运行结果" class="headerlink" title="输出下面代码运行结果"></a>输出下面代码运行结果</h4><p><img src="img/1.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* //example 1</span><br><span class="line">var a=&#123;&#125;, b=&apos;123&apos;, c=123;  </span><br><span class="line">a[b]=&apos;b&apos;;</span><br><span class="line">a[c]=&apos;c&apos;;  </span><br><span class="line">console.log(a[b]); //=&gt;c  因为：a[&quot;123&quot;] &lt;=&gt; a[123]</span><br><span class="line"></span><br><span class="line">//example 2</span><br><span class="line">var a=&#123;&#125;, b=Symbol(&apos;123&apos;), c=Symbol(&apos;123&apos;);  </span><br><span class="line">a[b]=&apos;b&apos;;</span><br><span class="line">a[c]=&apos;c&apos;;  </span><br><span class="line">console.log(a[b]);  //=&gt;Symbol是ES6中新增的数据类型  typeof Symbol(&apos;123&apos;)===&quot;symbol&quot;  它创建出来的值是唯一值  Symbol(&apos;123&apos;)===Symbol(&apos;123&apos;):FALSE</span><br><span class="line"></span><br><span class="line">//example 3</span><br><span class="line">var a=&#123;&#125;, b=&#123;key:&apos;123&apos;&#125;, c=&#123;key:&apos;456&apos;&#125;;  </span><br><span class="line">a[b]=&apos;b&apos;;</span><br><span class="line">a[c]=&apos;c&apos;;  </span><br><span class="line">console.log(a[b]);</span><br><span class="line">//1.对象的属性名不能是一个对象（遇到对象属性名，会默认转换为字符串）</span><br><span class="line">// obj=&#123;&#125;  arr=[12,23]  obj[arr]=&apos;珠峰&apos;  obj=&gt;&#123;&quot;12,23&quot;:&quot;珠峰&quot;&#125;</span><br><span class="line">//2.普通对象.toString() 调取的是Object.prototype上的方法（这个方法是用来检测数据类型的）</span><br><span class="line">// obj=&#123;&#125;  obj.toString()=&gt;&quot;[object Object]&quot; </span><br><span class="line">// obj[b]=&apos;b&apos;  =&gt; obj[&quot;[object Object]&quot;]=&apos;b&apos; */</span><br></pre></td></tr></table></figure>

<h4 id="在输入框中如何判断输入的是一个正确的网址，例如：用户输入一个字符串，验证是否符合URL网址的格式"><a href="#在输入框中如何判断输入的是一个正确的网址，例如：用户输入一个字符串，验证是否符合URL网址的格式" class="headerlink" title="在输入框中如何判断输入的是一个正确的网址，例如：用户输入一个字符串，验证是否符合URL网址的格式"></a>在输入框中如何判断输入的是一个正确的网址，例如：用户输入一个字符串，验证是否符合URL网址的格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;https://www.zhufengpeixun.com.cn&quot;;</span><br><span class="line">let reg = /^(?:(http|https|ftp):\/\/)?((?:[\w-]+\.)+[a-z0-9]+)((?:\/[^/?#]*)+)?(\?[^#]+)?(#.+)?$/i;</span><br><span class="line">console.log(reg.exec(str));</span><br><span class="line">//=&gt;URL格式</span><br><span class="line">//1.协议://  http/https/ftp</span><br><span class="line">//2.域名</span><br><span class="line">// www.zhufengpeixun.cn</span><br><span class="line">// zhufengpeixun.cn</span><br><span class="line">// kbs.sports.qq.com</span><br><span class="line">// kbs.sports.qq.com.cn</span><br><span class="line">//3.请求路径</span><br><span class="line">// /</span><br><span class="line">// /index.html</span><br><span class="line">// /stu/index.html</span><br><span class="line">// /stu/</span><br><span class="line">//4.问号传参</span><br><span class="line">// ?xxx=xxx&amp;xxx=xxx</span><br><span class="line">//5.哈希值</span><br><span class="line">// #xxx</span><br></pre></td></tr></table></figure>

<h4 id="编写代码实现图片的懒加载"><a href="#编写代码实现图片的懒加载" class="headerlink" title="编写代码实现图片的懒加载"></a>编写代码实现图片的懒加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">let $imgBox = $(&apos;.imgBox&apos;),</span><br><span class="line">	$img = $imgBox.children(&apos;img&apos;),</span><br><span class="line">	$window = $(window);</span><br><span class="line"></span><br><span class="line">//=&gt;JQ中的事件绑定支持多事件绑定：window.onload &amp; window.onscroll 两个事件触发的时候执行相同的事情</span><br><span class="line">$window.on(&apos;load scroll&apos;, function () &#123;</span><br><span class="line">	if ($img.attr(&apos;isLoad&apos;) === &apos;true&apos;) &#123;</span><br><span class="line">		//=&gt;之前加载过则不会重新加载</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	let $A = $imgBox.outerHeight() + $imgBox.offset().top,</span><br><span class="line">		$B = $window.outerHeight() + $window.scrollTop();</span><br><span class="line">	if ($A &lt;= $B) &#123;</span><br><span class="line">		//=&gt;加载真实图片</span><br><span class="line">		$img.attr(&apos;src&apos;, $img.attr(&apos;data-img&apos;));</span><br><span class="line">		$img.on(&apos;load&apos;, function () &#123;</span><br><span class="line">			//=&gt;加载成功：fadeIn是JQ中的渐现动画</span><br><span class="line">			// $img.css(&apos;display&apos;, &apos;block&apos;);</span><br><span class="line">			$img.stop().fadeIn();</span><br><span class="line">		&#125;);</span><br><span class="line">		$img.attr(&apos;isLoad&apos;, true); //=&gt;ATTR存储的自定义属性值都是字符串&quot;true&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;); */</span><br><span class="line"></span><br><span class="line">let $container = $(&apos;.container&apos;),</span><br><span class="line">	$imgBoxs = null,</span><br><span class="line">	$window = $(window);</span><br><span class="line"></span><br><span class="line">//=&gt;造点假数据 new Array(20).fill(null)创建长度为20的数组，每一项用null填充</span><br><span class="line">let str = ``;</span><br><span class="line">new Array(20).fill(null).forEach(item =&gt; &#123;</span><br><span class="line">	str += `&lt;div class=&quot;imgBox&quot;&gt;</span><br><span class="line">		&lt;img src=&quot;&quot; alt=&quot;&quot; data-img=&quot;http://www.zhufengpeixun.cn/main/img/banner10.png&quot;&gt;</span><br><span class="line">	&lt;/div&gt;`;</span><br><span class="line">&#125;);</span><br><span class="line">$container.html(str);</span><br><span class="line">$imgBoxs = $container.children(&apos;.imgBox&apos;);</span><br><span class="line"></span><br><span class="line">//=&gt;多张图片延迟加载</span><br><span class="line">$window.on(&apos;load scroll&apos;, function () &#123;</span><br><span class="line">	//$B:获取浏览器底边框距离BODY的距离</span><br><span class="line">	let $B = $window.outerHeight() + $window.scrollTop();</span><br><span class="line">	//循环每一个图片区域，根据自己区域距离BODY的距离，计算出里面的图片是否加载</span><br><span class="line">	$imgBoxs.each((index, item) =&gt; &#123;</span><br><span class="line">		let $item = $(item),</span><br><span class="line">			$itemA = $item.outerHeight() + $item.offset().top,</span><br><span class="line">			isLoad = $item.attr(&apos;isLoad&apos;);</span><br><span class="line">		if ($itemA &lt;= $B &amp;&amp; isLoad !== &apos;true&apos;) &#123;</span><br><span class="line">			$item.attr(&apos;isLoad&apos;, true);</span><br><span class="line">			//加载当前区域中的图片</span><br><span class="line">			let $img = $item.children(&apos;img&apos;);</span><br><span class="line">			$img.attr(&apos;src&apos;, $img.attr(&apos;data-img&apos;));</span><br><span class="line">			$img.on(&apos;load&apos;, () =&gt; $img.stop().fadeIn());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);o7</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="编写一条正则，用来验证此规则：一个6-16位的字符串，必须同时包含有大小写字母和数字"><a href="#编写一条正则，用来验证此规则：一个6-16位的字符串，必须同时包含有大小写字母和数字" class="headerlink" title="编写一条正则，用来验证此规则：一个6~16位的字符串，必须同时包含有大小写字母和数字"></a>编写一条正则，用来验证此规则：一个6~16位的字符串，必须同时包含有大小写字母和数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let reg = /(?!^[a-zA-Z]+$)(?!^[0-9]+$)(?!^[a-z0-9]+$)(?!^[A-Z0-9]+$)^[a-zA-Z0-9]&#123;6,16&#125;$/;</span><br><span class="line"></span><br><span class="line">/* 1-10位：数字、字母、下划线组成字符串，必须有_ */</span><br><span class="line">// let reg = /(?!^[a-zA-Z0-9]+$)^\w&#123;1,10&#125;$/;</span><br><span class="line"></span><br><span class="line">/* 字符串中包含 “\w”，但是必须包含_ */</span><br><span class="line">// let reg = /(?=_)\w+/;</span><br></pre></td></tr></table></figure>

<h4 id="完成如下需求"><a href="#完成如下需求" class="headerlink" title="完成如下需求"></a>完成如下需求</h4><p><img src="img/2.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* 实现一个$attr(name,value)遍历</span><br><span class="line"> * 属性为name</span><br><span class="line"> * 值为value的元素集合</span><br><span class="line"> * </span><br><span class="line"> * 例如下面示例:</span><br><span class="line"> */</span><br><span class="line"> function $attr(property, value) &#123;</span><br><span class="line">	//=&gt;获取当前页面中所有的标签</span><br><span class="line">	let elements = document.getElementsByTagName(&apos;*&apos;),</span><br><span class="line">		arr = [];</span><br><span class="line">	// [].forEach.call(elements, item =&gt; &#123;&#125;);</span><br><span class="line">	elements = Array.from(elements); //=&gt;把非数组转换为数组</span><br><span class="line">	elements.forEach(item =&gt; &#123;</span><br><span class="line">		//=&gt;存储的是当前元素PROPERTY对应的属性值</span><br><span class="line">		let itemValue = item.getAttribute(property);</span><br><span class="line">		if (property === &apos;class&apos;) &#123;</span><br><span class="line">			//=&gt;样式类属性名要特殊的处理</span><br><span class="line">			new RegExp(&quot;\\b&quot; + value + &quot;\\b&quot;).test(itemValue) ? arr.push(item) : null;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if (itemValue === value) &#123;</span><br><span class="line">			//=&gt;获取的值和传递的值校验成功：当前就是我们想要的</span><br><span class="line">			arr.push(item);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	return arr;</span><br><span class="line">&#125;</span><br><span class="line">console.log($attr(&apos;class&apos;, &apos;box&apos;));</span><br></pre></td></tr></table></figure>

<h4 id="英文字母汉字组成的字符串，用正则给英文单词前后加空格"><a href="#英文字母汉字组成的字符串，用正则给英文单词前后加空格" class="headerlink" title="英文字母汉字组成的字符串，用正则给英文单词前后加空格"></a>英文字母汉字组成的字符串，用正则给英文单词前后加空格</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;no作no死，你能你can，不能no哔哔！&quot;,</span><br><span class="line">reg = /\b[a-z]+\b/ig;</span><br><span class="line">str = str.replace(reg, value =&gt; &#123;</span><br><span class="line">return &quot; &quot; + value + &quot; &quot;;</span><br><span class="line"> &#125;).trim();            //=&gt;String.prototype.trim/.trimLeft/.trimRight 去除字符串首尾空格</span><br><span class="line"> console.log(str);</span><br></pre></td></tr></table></figure>

<h4 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//=&gt;使用ES6中提供的 Array.prototype.flat 处理</span><br><span class="line">// arr = arr.flat(Infinity);</span><br><span class="line"></span><br><span class="line">//=&gt;把数组直接变为字符串即可（数组TOSTRING之后，不管你有多少级，最后都会变为以逗号分隔的字符串，没有中括号和所谓的层级了），相当于直接的扁平化了</span><br><span class="line">// arr = arr.toString().split(&apos;,&apos;).map(item =&gt; &#123;</span><br><span class="line">// 	return Number(item);</span><br><span class="line">// &#125;);</span><br><span class="line"></span><br><span class="line">//=&gt;JSON.stringify也可以扁平化数组</span><br><span class="line">// JSON.stringify(arr) : &quot;[[1,2,2],[3,4,5,5],[6,7,8,9,...&quot;</span><br><span class="line">// replace(/(\[|\])/g, &apos;&apos;) : &quot;1,2,2,3,4,5,5,6,7,8,9...&quot;</span><br><span class="line">// arr = JSON.stringify(arr).replace(/(\[|\])/g, &apos;&apos;).split(&apos;,&apos;).map(item =&gt; Number(item));</span><br><span class="line"></span><br><span class="line">//=&gt;基于数组的some方法进行判断检测：验证数组中的某一项有没有符合函数中提供的规则的</span><br><span class="line">//=&gt;find和some的区别：some返回的是boolean，find找到符合规则的，返回当前这一项，没找到符合规则的，返回undefined</span><br><span class="line">//=&gt;Array.isArray([val])：检测某个值是否为数组类型（挺准的）</span><br><span class="line">/* var A = [2, 3, 4, 5];</span><br><span class="line">var B = A.find(item =&gt; &#123;</span><br><span class="line">	return item &lt; 6;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(B); */</span><br><span class="line">// while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line">// 	arr = [].concat(...arr);</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">//=&gt;自己递归处理</span><br><span class="line">~ function () &#123;</span><br><span class="line">	function myFlat() &#123;</span><br><span class="line">		let result = [],</span><br><span class="line">			_this = this;</span><br><span class="line">		//=&gt;循环ARR中的每一项，把不是数组的存储到新数组中</span><br><span class="line">		let fn = (arr) =&gt; &#123;</span><br><span class="line">			for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">				let item = arr[i];</span><br><span class="line">				if (Array.isArray(item)) &#123;</span><br><span class="line">					fn(item);</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				result.push(item);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		fn(_this);</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">	Array.prototype.myFlat = myFlat;</span><br><span class="line">&#125;();</span><br><span class="line">arr = arr.myFlat();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//=&gt;基于ES6中的new Set()去重数组（也可以自己写方法）</span><br><span class="line">// [...new Set(arr)]</span><br><span class="line">// Array.from(new Set(arr))</span><br><span class="line">arr = Array.from(new Set(arr)).sort((a, b) =&gt; a - b);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

<h4 id="重构内置new方法"><a href="#重构内置new方法" class="headerlink" title="重构内置new方法"></a>重构内置new方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function Dog(name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.bark = function () &#123;</span><br><span class="line">	console.log(&apos;wangwang&apos;);</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.sayName = function () &#123;</span><br><span class="line">	console.log(&apos;my name is &apos; + this.name);</span><br><span class="line">&#125;</span><br><span class="line">//=&gt;Fn当前要NEW的类  =&gt;Dog</span><br><span class="line">//=&gt;ARG后期需要给构造函数传递的参数信息  =&gt;[&apos;三毛&apos;]</span><br><span class="line">function _new(Fn, ...arg) &#123;</span><br><span class="line">	//=&gt;创建一个空对象，让他的原型链指向Fn.prototype（作为Fn的一个实例）</span><br><span class="line">	//=&gt;Object.create([AA对象])：创建一个空对象obj，并且让空对象obj作为AA对象所属构造函数的实例（obj.__proto__=AA）</span><br><span class="line">	// let obj = &#123;&#125;;</span><br><span class="line">	// obj.__proto__ = Fn.prototype;</span><br><span class="line">	let obj = Object.create(Fn.prototype);</span><br><span class="line">	Fn.call(obj, ...arg);</span><br><span class="line">	return obj;</span><br><span class="line">&#125;</span><br><span class="line">let sanmao = _new(Dog, &apos;三毛&apos;);</span><br><span class="line">/* </span><br><span class="line"> * let sanmao=new Dog(&apos;三毛&apos;); </span><br><span class="line"> *   1.像普通函数执行一样，形成一个私有的作用域</span><br><span class="line"> *     + 形参赋值</span><br><span class="line"> *     + 变量提升</span><br><span class="line"> *   2.默认创建一个对象,让函数中的this执行这个对象,这个对象就是当前类的一个实例</span><br><span class="line"> *   3.代码执行</span><br><span class="line"> *   4.默认把创建的对象返回</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//=&gt;基于内置的new关键词，我们可以创建Dog的一个实例sanmao，实例可以调取原型上的属性和方法，现在的需求是：自己实现一个_new方法，也能模拟出内置new后的结果</span><br><span class="line">// function _new() &#123;</span><br><span class="line">// 	//=&gt;完成你的代码</span><br><span class="line">// &#125;</span><br><span class="line">sanmao.bark(); //=&gt;&quot;wangwang&quot;</span><br><span class="line">sanmao.sayName(); //=&gt;&quot;my name is 三毛&quot;</span><br><span class="line">console.log(sanmao instanceof Dog); //=&gt;true</span><br></pre></td></tr></table></figure>

<h4 id="两个数组和并为一个数组"><a href="#两个数组和并为一个数组" class="headerlink" title="两个数组和并为一个数组"></a>两个数组和并为一个数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let ary1 = [&apos;D1&apos;, &apos;D2&apos;, &apos;A1&apos;, &apos;A2&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;B1&apos;, &apos;B2&apos;];</span><br><span class="line">let ary2 = [&apos;B&apos;, &apos;A&apos;, &apos;D&apos;, &apos;C&apos;];</span><br><span class="line">//=&gt;合并后的数组为：[&apos;D1&apos;, &apos;D2&apos;,&apos;D&apos;, &apos;A1&apos;, &apos;A2&apos;,&apos;A&apos;, &apos;C1&apos;, &apos;C2&apos;,&apos;C&apos; ,&apos;B1&apos;, &apos;B2&apos;,&apos;B&apos;]</span><br><span class="line">ary2 = ary2.map(item =&gt; item + &apos;珠峰&apos;);</span><br><span class="line">let arr = ary1.concat(ary2);</span><br><span class="line">arr = arr.sort((a, b) =&gt; a.localeCompare(b)).map(item =&gt; &#123;</span><br><span class="line">	return item.replace(&apos;珠峰&apos;, &apos;&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr); </span><br><span class="line"></span><br><span class="line">/* let n = 0;</span><br><span class="line">for (let i = 0; i &lt; ary2.length; i++) &#123;</span><br><span class="line">	let item2 = ary2[i];</span><br><span class="line">	for (let k = 0; k &lt; ary1.length; k++) &#123;</span><br><span class="line">		let item1 = ary1[k];</span><br><span class="line">		if (item1.includes(item2)) &#123;</span><br><span class="line">			//=&gt;如果包含就记录一下当前这一项的索引位置（后面还有包含的会重新记录这个值）</span><br><span class="line">			n = k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//=&gt;把当前ITEM2这一项插入到ARY1中N的后面</span><br><span class="line">	ary1.splice(n + 1, 0, item2);</span><br><span class="line">&#125;</span><br><span class="line">console.log(ary1); */</span><br></pre></td></tr></table></figure>

<h4 id="改造下面代码，使之输出0-9"><a href="#改造下面代码，使之输出0-9" class="headerlink" title="改造下面代码，使之输出0-9"></a>改造下面代码，使之输出0-9</h4><p><img src="img/3.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//=&gt;定时器是异步编程：每一轮循环设置定时器，无需等定时器触发执行，继续下一轮循环（定时器触发的时候，循环已经结束了）</span><br><span class="line">/* for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">	//=&gt;LET存在块级作用域，每一次循环都会在当前块作用域中形成一个私有变量i存储0~9</span><br><span class="line">	//当定时器执行的时候，所使用的i就是所处块作用域中的i</span><br><span class="line">	setTimeout(() =&gt; &#123;</span><br><span class="line">		console.log(i);</span><br><span class="line">	&#125;, 1000);</span><br><span class="line">&#125; */</span><br><span class="line"></span><br><span class="line">//=&gt;闭包解决</span><br><span class="line">/* for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">	~ function (i) &#123;</span><br><span class="line">		setTimeout(() =&gt; &#123;</span><br><span class="line">			console.log(i);</span><br><span class="line">		&#125;, 1000);</span><br><span class="line">	&#125;(i);</span><br><span class="line">&#125; */</span><br><span class="line">/* for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">	setTimeout((i =&gt; () =&gt; console.log(i))(i), 1000);</span><br><span class="line">&#125; */</span><br><span class="line"></span><br><span class="line">//=&gt;可以基于bind的预先处理机制：在循环的时候就把每次执行函数需要输出的结果，预先传给函数即可</span><br><span class="line">/* var fn = function (i) &#123;</span><br><span class="line">	console.log(i);</span><br><span class="line">&#125;;</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">	setTimeout(fn.bind(null, i), 1000);</span><br><span class="line">&#125; */</span><br></pre></td></tr></table></figure>

<h4 id="下面代码输出的结果是多少，为什么？如何改造一下，就能让其输出-20-10？"><a href="#下面代码输出的结果是多少，为什么？如何改造一下，就能让其输出-20-10？" class="headerlink" title="下面代码输出的结果是多少，为什么？如何改造一下，就能让其输出 20 10？"></a>下面代码输出的结果是多少，为什么？如何改造一下，就能让其输出 20 10？</h4><p><img src="img/4.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* var b = 10;</span><br><span class="line">(function b() &#123;</span><br><span class="line">	b = 20;</span><br><span class="line">	console.log(b); //=&gt;函数</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(b); //=&gt;10 */</span><br><span class="line"></span><br><span class="line">/* let fn = function AAA() &#123;</span><br><span class="line">	// &quot;use strict&quot;;</span><br><span class="line">	// AAA = 1000; //=&gt;Uncaught TypeError: Assignment to constant variable.</span><br><span class="line">	console.log(AAA); //=&gt;当前函数</span><br><span class="line">&#125;;</span><br><span class="line">// AAA(); //=&gt;Uncaught ReferenceError: AAA is not defined  </span><br><span class="line">// 1.本应匿名的函数如果设置了函数名，在外面还是无法调用，但是在函数里面是可以使用的</span><br><span class="line">// 2.而且类似于创建常量一样，这个名字存储的值不能再被修改（非严格模式下不错报，但是不会有任何的效果，严格模式下直接报错，我们可以把AAA理解为是用 const 创建出来的）</span><br><span class="line">fn(); */</span><br><span class="line"></span><br><span class="line">/* var b = 10;</span><br><span class="line">(function b(b) &#123;</span><br><span class="line">	b = 20;</span><br><span class="line">	console.log(b); //=&gt;20 里面的b一定需要是私有的，不能是全局的（声明它或者改为形参）</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(b); //=&gt;10 */</span><br></pre></td></tr></table></figure>

<h4 id="对象比较"><a href="#对象比较" class="headerlink" title="对象比较"></a>对象比较</h4><p><img src="img/5.png" alt="Alt text"></p>
<p>==进行比较的时候，如果左边数据类型不一样，则先转换为相同的数据类型，然后进行比较。</p>
<ol>
<li>{} == {} 对象比较的是堆内存的地址</li>
<li><code>null == undefined   true  null === undefined false</code></li>
<li>NaN == NaN  false</li>
<li>[12] == ‘12’   对象和字符串比较 是把对象to string（）转换为字符串后再Number再进行比较</li>
<li>剩余的情况比较都是转换为数字再进行比较</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//=&gt;对象和数字比较：先把对象.toString()变为字符串，然后再转换为数字</span><br><span class="line"> var a = &#123;</span><br><span class="line">	n: 0,</span><br><span class="line">	//=&gt;私有的属性方法</span><br><span class="line">	toString: function () &#123;</span><br><span class="line">		return ++this.n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">// a.toString(); //=&gt;此时调取的就不再是Object.prototype.toString了，调取的是自己私有的</span><br><span class="line">if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;</span><br><span class="line">	console.log(&apos;OK&apos;);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//=&gt;shift:删除数组第一项，把删除的内容返回，原有数组改变</span><br><span class="line"> let a = [1, 2, 3];</span><br><span class="line"> a.toString = a.shift;</span><br><span class="line"> if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;</span><br><span class="line">	console.log(&apos;OK&apos;);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> * ES6中新增加的一些方法</span><br><span class="line"> *   String.fromCharCode([n])  &lt;=&gt; &quot;z&quot;.charCodeAt()  </span><br><span class="line"> *   Array.from()</span><br><span class="line"> *   Array.isArray() </span><br><span class="line"> *   Object.create([OBJ])</span><br><span class="line"> *   Object.defineProperty()</span><br><span class="line"> </span><br><span class="line"> let obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &apos;name&apos;, &#123;</span><br><span class="line">	get: function () &#123;</span><br><span class="line">		console.log(&apos;哈哈&apos;);</span><br><span class="line">		return &quot;珠峰培训&quot;;</span><br><span class="line">	&#125;,</span><br><span class="line">	set: function () &#123;</span><br><span class="line">		console.log(&apos;呵呵呵&apos;);</span><br><span class="line">		this.value = &quot;呵呵呵&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">Object.defineProperty(window, &apos;a&apos;, &#123;</span><br><span class="line">	get: function () &#123;</span><br><span class="line">		//=&gt;this:window.a</span><br><span class="line">		this.value ? this.value++ : this.value = 1;</span><br><span class="line">		return this.value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;</span><br><span class="line">	console.log(&apos;OK&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="下面代码的输出结果？push源码"><a href="#下面代码的输出结果？push源码" class="headerlink" title="下面代码的输出结果？push源码"></a>下面代码的输出结果？push源码</h4><p><img src="img/6.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.push = function @@(val) &#123;</span><br><span class="line">	this[this.length] = val;</span><br><span class="line">	//=&gt;this.length在原来的基础上加1</span><br><span class="line">	return this.length;</span><br><span class="line">&#125;</span><br><span class="line"> let obj = &#123;</span><br><span class="line">	2: 3, //=&gt;1</span><br><span class="line">	3: 4, //=&gt;2</span><br><span class="line">	length: 2, //=&gt;3/4</span><br><span class="line">	push: Array.prototype.push</span><br><span class="line">&#125;</span><br><span class="line">obj.push(1);</span><br><span class="line">//=&gt;@@(1)  //=&gt;this:obj  //=&gt;obj[obj.length]=1  //=&gt;obj[2]=1  //=&gt;obj.length=3</span><br><span class="line">obj.push(2);</span><br><span class="line">//=&gt;@@(2)  //=&gt;this:obj  //=&gt;obj[obj.length]=2  //=&gt;obj[3]=2  //=&gt;obj.length=4</span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure>

<h4 id="冒泡排序如何实现，时间复杂度是多少，-还可以如何改进？"><a href="#冒泡排序如何实现，时间复杂度是多少，-还可以如何改进？" class="headerlink" title="冒泡排序如何实现，时间复杂度是多少， 还可以如何改进？"></a>冒泡排序如何实现，时间复杂度是多少， 还可以如何改进？</h4><h4 id="完成如下需求-1"><a href="#完成如下需求-1" class="headerlink" title="完成如下需求"></a>完成如下需求</h4><p><img src="img/7.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// let obj = &#123;</span><br><span class="line">// 	1: 222,</span><br><span class="line">// 	2: 123,</span><br><span class="line">// 	5: 888</span><br><span class="line">// &#125;;</span><br><span class="line">// let arr = new Array(12).fill(null).map((item, index) =&gt; &#123;</span><br><span class="line">// 	return obj[index + 1] || null;</span><br><span class="line">// &#125;);</span><br><span class="line">// console.log(arr);</span><br><span class="line"></span><br><span class="line">// let obj = &#123;</span><br><span class="line">// 	1: 222,</span><br><span class="line">// 	2: 123,</span><br><span class="line">// 	5: 888</span><br><span class="line">// &#125;;</span><br><span class="line">// obj.length = 13;</span><br><span class="line">// let arr = Array.from(obj).slice(1).map(item =&gt; &#123;</span><br><span class="line">// 	return typeof item === &quot;undefined&quot; ? null : item;</span><br><span class="line">// &#125;);</span><br><span class="line">// console.log(arr);</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">	1: 222,</span><br><span class="line">	2: 123,</span><br><span class="line">	5: 888</span><br><span class="line">&#125;;</span><br><span class="line">//=&gt;Object.keys(obj):获取obj中所有的属性名，以数组的方式返回</span><br><span class="line">// console.log(Object.keys(obj)); //=&gt;[&quot;1&quot;,&quot;2&quot;,&quot;5&quot;]</span><br><span class="line">let arr = new Array(12).fill(null);</span><br><span class="line">Object.keys(obj).forEach(item =&gt; &#123;</span><br><span class="line">	arr[item - 1] = obj[item];</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

<h4 id="给定两个数组，-写一个方法来计算它们的交集"><a href="#给定两个数组，-写一个方法来计算它们的交集" class="headerlink" title="给定两个数组， 写一个方法来计算它们的交集"></a>给定两个数组， 写一个方法来计算它们的交集</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> let nums1 = [12, 23, 34, 23, 45, 34, 25, 46, 35];</span><br><span class="line">let nums2 = [10, 35, 24, 23, 36, 47, 56];</span><br><span class="line">let arr = [];</span><br><span class="line">nums1.forEach((item, index) =&gt; &#123;</span><br><span class="line">	//=&gt;index是第一个数组当前项的索引</span><br><span class="line">	//=&gt;n当前项在第二个数组中找到相同那一项的索引</span><br><span class="line">	let n = nums2.indexOf(item);</span><br><span class="line">	if (n &gt;= 0) &#123;</span><br><span class="line">		arr.push(item);</span><br><span class="line">		nums1.splice(index, 1);</span><br><span class="line">		nums2.splice(n, 1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;); </span><br><span class="line">// console.log(arr);</span><br></pre></td></tr></table></figure>

<h4 id="算法题「旋转数组」"><a href="#算法题「旋转数组」" class="headerlink" title="算法题「旋转数组」"></a>算法题「旋转数组」</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">旋转数组</span><br><span class="line">给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数</span><br><span class="line">输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3</span><br><span class="line">输出: [5, 6, 7, 1, 2, 3, 4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7, 1, 2, 3, 4, 5, 6]</span><br><span class="line">向右旋转 2 步: [6, 7, 1, 2, 3, 4, 5]</span><br><span class="line">向右旋转 3 步: [5, 6, 7, 1, 2, 3, 4]</span><br><span class="line">​</span><br><span class="line">输入: [-1, -100, 3, 99] 和 k = 2</span><br><span class="line">输出: [3, 99, -1, -100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99, -1, -100, 3]</span><br><span class="line">向右旋转 2 步: [3, 99, -1, -100] </span><br><span class="line">*/</span><br><span class="line">/* function rotate(k) &#123;</span><br><span class="line">	//=&gt;参数处理</span><br><span class="line">	if (k &lt; 0 || k === 0 || k === this.length) return this;</span><br><span class="line">	if (k &gt; this.length) k = k % this.length;</span><br><span class="line">	//=&gt;旋转数组</span><br><span class="line">	// return this.slice(-k).concat(this.slice(0, this.length - k));</span><br><span class="line">	// return [...this.splice(this.length - k), ...this];</span><br><span class="line"></span><br><span class="line">	/!* for (let i = 0; i &lt; k; i++) &#123;</span><br><span class="line">		this.unshift(this.pop());</span><br><span class="line">	&#125; *!/</span><br><span class="line">	new Array(k).fill(&apos;&apos;).forEach(() =&gt; this.unshift(this.pop()));</span><br><span class="line">	return this;</span><br><span class="line">&#125;</span><br><span class="line">Array.prototype.rotate = rotate;</span><br><span class="line"></span><br><span class="line">let arr = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line">console.log(arr.rotate(3)); */</span><br></pre></td></tr></table></figure>

<h4 id="函数柯理化：预先处理思想（利用闭包的机制）"><a href="#函数柯理化：预先处理思想（利用闭包的机制）" class="headerlink" title="函数柯理化：预先处理思想（利用闭包的机制）"></a>函数柯理化：预先处理思想（利用闭包的机制）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/* 函数柯理化：预先处理的思想（利用闭包的机制） */</span><br><span class="line">/* function fn(x)&#123;</span><br><span class="line">	//=&gt;预先在闭包中把X值存储起来</span><br><span class="line">	return function(y)&#123;</span><br><span class="line">		return x+y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(100)(200) */</span><br><span class="line">/* (function () &#123;</span><br><span class="line">	//=&gt;this:需要改变THIS的函数</span><br><span class="line">	//=&gt;context:需要改变的THIS指向</span><br><span class="line">	//=&gt;outerArg:其余需要传递给函数的实参信息</span><br><span class="line">	function myBind(context = window, ...outerArg) &#123;</span><br><span class="line">		let _this = this; </span><br><span class="line">		return function anonymous(...innerArg) &#123;</span><br><span class="line">			_this.call(context, ...outerArg.concat(innerArg));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Function.prototype.myBind = myBind;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">	name: &apos;OBJ&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function fn(...arg) &#123;</span><br><span class="line">	console.log(this, arg);</span><br><span class="line">&#125;</span><br><span class="line">document.body.onclick = fn.myBind(obj, 100, 200);;</span><br><span class="line"> */</span><br><span class="line">//=&gt;点击的时候FN中的this=&gt;obj arg=&gt;[100,200,事件对象]</span><br><span class="line">// document.body.onclick = fn.bind(obj, 100, 200);</span><br><span class="line">// document.body.onclick = function (ev) &#123;</span><br><span class="line">// 	fn.call(obj, 100, 200, ev);</span><br><span class="line">// &#125;</span><br><span class="line">//=&gt;执行bind方法，会返回一个匿名函数，当事件触发，匿名函数执行，我们再处理fn即可</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// document.body.onclick = fn; //=&gt;this:BODY  arg:[事件对象]</span><br><span class="line">/* document.body.onclick = function (ev) &#123;</span><br><span class="line">	//=&gt;ev事件对象：给元素的某个事件绑定方法，当事件触发会执行这个方法，并且会把当前事件的相关信息传递给这个函数“事件对象”</span><br><span class="line">	console.log(ev);</span><br><span class="line">&#125; */</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    



    
    <div>
    

    



    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </div></article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangyiye.github.io/2018/03/26/Vue-指令及基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiYe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yiYe's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/26/Vue-指令及基础知识/" itemprop="url">Vue指令及基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T11:48:49+08:00">
                2018-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/03/26/Vue-指令及基础知识/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::https://wangyiye.github.io/2018/03/26/Vue-指令及基础知识/" class="cy_cmt_count" data-xid="2018/03/26/Vue-指令及基础知识/" itemprop="commentsCount"></span>
                </a>
              
            
          

          
          
             <span id="/2018/03/26/Vue-指令及基础知识/" class="leancloud_visitors" data-flag-title="Vue指令及基础知识">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </span></div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">


      
      

      
        
          
            <h2 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h2><ul>
<li>数据驱动:<strong>操作DOM</strong></li>
<li>JS的数据类型 基本 和 引用</li>
<li>改变原数组 —&gt; 数组的变异 <strong>pop push shif unshift reverse sort splice(n,m,x,y,z)</strong></li>
<li>不改变原数组 —&gt; <strong>slice(n,m) concat indexOf join(‘+’) toString()</strong></li>
<li>数组的迭代方法 <ul>
<li>forEach </li>
<li>map:renturn什么值，就往新数组添加新属性，若没有return值，就添加undefined</li>
<li>filter<ul>
<li>1)filter的回调函数中return值，若是true，则把当前迭代的项复制一份到新数组arr中</li>
<li>2)filter的返回值是新数组arr</li>
</ul>
</li>
<li>some:<ul>
<li>1)回调函数中只要有一个回调函数返回的是true，则整个some 返回值就是ture</li>
<li>2)只要某个项满足条件，就不在进行迭代</li>
</ul>
</li>
<li>every:<ul>
<li>1)回调函数，每一个都是true，every的返回值才是true</li>
<li>2)换句话说就是只要有一个是false ，整个结果就是false</li>
</ul>
</li>
<li>reduce((prev,next)=&gt;):结果就是最后一次迭代的return值</li>
<li>find: 找到满足条件的第一项</li>
<li>includes(item,index)从index索引值开始查找 找到就是true 找不到就是false</li>
</ul>
</li>
</ul>
<h2 id="NODE基础命令"><a href="#NODE基础命令" class="headerlink" title="NODE基础命令"></a>NODE基础命令</h2><ul>
<li>package.json 是项目的依赖表单</li>
<li>dependencies:存储的都是生产环境的依赖</li>
<li>devdependencies:储存的都是开发环境的依赖</li>
<li>scripts:中存储的都是要执行的命令对应的代码</li>
<li>npm run hello : 对应的要执行hello对应的代码</li>
<li>npm i vue –save:在项目中添加依赖，安装依赖</li>
<li>npm i yarn -g : 全局安装yarn，以后可以使用yarn代替npm 去安装一些依赖</li>
</ul>
<h2 id="VUE-M-V-VM"><a href="#VUE-M-V-VM" class="headerlink" title="VUE - M-V-VM"></a>VUE - M-V-VM</h2><ul>
<li>1.vue 双向数据绑定 ；渐进式；框架</li>
<li>2.视图 V 数据 M  VM</li>
<li>3.视图改变 数据自动更新</li>
<li>4.数据更新 视图自动更改</li>
<li>5.渐进式: SPA 单页面开发<ul>
<li>核心:vue.js  </li>
<li>vue-router控制路由 </li>
<li>vuex 处理数据</li>
<li>axios 解决请求</li>
</ul>
</li>
</ul>
<p><img src="Vue-%E6%8C%87%E4%BB%A4%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/MVC-MVVM%E6%A6%82%E8%AE%BA.png" alt="MVC 和 MVVM"></p>
<h2 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h2><ul>
<li>编程式 forEach </li>
<li>声明式 for() 编程式</li>
</ul>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ul>
<li>框架:自己写的代码被框架调用 Vue React Angular BootStrap </li>
<li>库: 自己调用库的代码</li>
</ul>
<h2 id="Vue的指令"><a href="#Vue的指令" class="headerlink" title="Vue的指令"></a>Vue的指令</h2><ul>
<li>1.v-model: 是vue的指令 name是实例的变量 指令是指让对应的元素做某件事</li>
<li>2.v-text : 展示对应的文本</li>
<li>3.v-once : 对应的标签只渲染一次 1~3指令都是行内属性</li>
<li>4.v-html : 把值中的标签渲染出来</li>
<li>5.v-cloak : <strong>解决渲染闪烁问题</strong><pre><code>[v-cloak] {display: none;} 
&lt;div v-cloak&gt;{{ message }}&lt;/div&gt;</code></pre></li>
<li>6.v-show : 控制元素的display:ngone 属性</li>
<li>7.v-on:click : 给元素绑定事件 简写 <code>@click = &#39;fn&#39;</code></li>
<li>8.v-keyup.enter = ‘fn’ : 给元素绑定键盘事件</li>
<li>9.v-bind:绑定样式 对象 路径 缩写: <code>:</code></li>
<li>10.v-for : 循环显示元素的,可以循环数组，也可以循环<code>对象、字符串、数字</code> ，v-for优先级比v-if/else的优先级高，先渲染v-for</li>
<li>11.v-if / v-else-if /v-else :直接不加载元素,先做循环再做判断<h3 id="v-model指令"><a href="#v-model指令" class="headerlink" title="v-model指令"></a>v-model指令</h3></li>
<li><code>实现 数据和视图 双向绑定 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt;等表单元素和components组件</code></li>
<li>单个复选框，绑定到布尔值：  <input type="checkbox" id="checkbox" v-model="checked">

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>CheckBox 多个复选框,绑定到同一个数组：<code>check = []</code><br>  <input type="checkbox" value="CSS" v-model="check"> CSS<br>  <input type="checkbox" value="HTML" v-model="check">HTML<br>  <input type="checkbox" value="JS" v-model="check">JS</li>
<li>check 若为 [] <code>一个数组</code>  则3个input框能联系在一起,选择input框，则会在数组中push表单框中的value值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">radio 单选框</span><br><span class="line">	&lt;!-- 多个input绑定同一个变量即可 --&gt;</span><br><span class="line">	&lt;input type=&quot;radio&quot; v-model=&quot;fruit&quot; value=&quot;1&quot;/&gt;🍎</span><br><span class="line">	&lt;input type=&quot;radio&quot; v-model=&quot;fruit&quot; value=&quot;2&quot;/&gt;🍌</span><br><span class="line">	&lt;input type=&quot;radio&quot; v-model=&quot;fruit&quot; value=&quot;3&quot;/&gt;🍊</span><br></pre></td></tr></table></figure>

<h2 id="v-model实现数据双向绑定的原理"><a href="#v-model实现数据双向绑定的原理" class="headerlink" title="v-model实现数据双向绑定的原理"></a>v-model实现数据双向绑定的原理</h2><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><ul>
<li>获取数据，当属性依赖于其他data中属性时，其他数据改变，才会触发这个方法，但必不会触发set方法</li>
<li>最终值是由get方法决定的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj,&apos;name&apos;,&#123;</span><br><span class="line">	get()&#123;return 123&#125;,</span><br><span class="line">    set(val)&#123;</span><br><span class="line">        console.log(val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.name = 333;</span><br><span class="line">console.log(obj.name)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h4><ul>
<li>使用v-model:进行数据的双向绑定 只有点击改变值的时候，才会触发这个方法，触发这个方法必然触发了get方法</li>
<li><img src="Vue-%E6%8C%87%E4%BB%A4%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.png" alt="get与set的区别"></li>
</ul>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ul>
<li>self: 只有点击元素本身的时候才触发</li>
<li>stop:阻止冒泡</li>
<li>prevent:阻止默认事件</li>
<li>once: 对应的函数只触发一次</li>
<li>capture: 让事件在捕获阶段触发</li>
<li>passive : 优先执行默认事件，在执行绑定的函数，优化移动端性能，只对滚动行为有效<h3 id="v-model修饰符"><a href="#v-model修饰符" class="headerlink" title="v-model修饰符"></a>v-model修饰符</h3></li>
<li>number : 将字符串转化为数字 类似 parsefloat的效果</li>
<li>trim : 自动去除首尾空格</li>
</ul>
<h2 id="自定义全局键码"><a href="#自定义全局键码" class="headerlink" title="自定义全局键码"></a>自定义全局键码</h2><p><code>Vue.config.keyCodes.f2 = 113</code> =&gt; 在模板中可以这样使用 <code>@keyup.f2 = fn&#39;&#39;</code>·</p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;money | changeM&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>管道符前边是要处理的数据，后边是处理的参数，最终展示的是函数的返回值</li>
<li>过滤器是可以连续使用的，下一个过滤器的返回值，是上一个过滤器的返回值</li>
<li>全局过滤器和私有过滤器，全局过滤器任何组件都可以调用，私有过滤器只有定义过滤器的组件可以调用</li>
<li>filter 中的方法 可以重名，不会被冲掉，但尽可能不要重名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(&apos;过滤器名称&apos;，function()&#123;&#125;) 全局过滤器</span><br><span class="line">	console.log(this) //=&gt; this 指向window</span><br><span class="line">在vm实例中定义</span><br><span class="line">filters:&#123;</span><br><span class="line">	&apos;过滤器名称&apos;:functon()&#123;&#125;</span><br><span class="line">&#125; 私有过滤器</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="侦听器-Watch"><a href="#侦听器-Watch" class="headerlink" title="侦听器 Watch"></a>侦听器 Watch</h2><ul>
<li>异步用监听,但是比较耗性能，能够深层监听，能够返回oldV 和 newV 两个值供实例调用</li>
<li>深层监听的属性必须是有set和get方法的属性值</li>
<li>当监听一个数组的时候，若数组地址不发生改变，那么不会触发watch的方法</li>
<li>Watch还可以监听到路由的变化</li>
<li>具有局限性，当监听的数据过多时，不适合使用watch方法</li>
</ul>
<h2 id="计算属性-Computed"><a href="#计算属性-Computed" class="headerlink" title="计算属性 Computed"></a>计算属性 Computed</h2><ul>
<li><p>同步用计算属性，但依赖性太强，用到get/set方法</p>
</li>
<li><p>定义的方法，挂载在vm的实例，不能跟methods和data重名，但是现在不报错，但是不能用，因为methods中的方法会把computed中的方法冲掉</p>
</li>
<li><p>只要name不发生改变，name2就不发生改变</p>
</li>
<li><p>name2用到谁，就依赖谁</p>
</li>
<li><p>conputed计算属性，具有缓存机制，若数据发生改变，会重新计算属性，若只是重复调用，则不会触发computed方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">	name2()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name.split(<span class="string">''</span>).rerverse().join(<span class="string">''</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	name3()&#123;</span><br><span class="line">		<span class="keyword">get</span>()&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="keyword">set</span>(val)&#123;</span><br><span class="line">			<span class="comment">// 给name3赋值的时候会触发, set函数</span></span><br><span class="line">			<span class="comment">// val 是外界</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>computed / watch / methods 三者的区别</p>
<ul>
<li><code>computed</code> : 属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算，主要当做属性来使用</li>
<li><code>watch</code> : 一个对象，键是需要观察的表达式，值是对应的回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，可以看作是<code>methods</code>和<code>computed</code>的结合体</li>
<li><code>methods</code> : 表示一个具体的操作，主要书写业务逻辑<h2 id="自定义全局指令"><a href="#自定义全局指令" class="headerlink" title="自定义全局指令"></a>自定义全局指令</h2></li>
</ul>
</li>
<li><p>使用directive定义全局的指令</p>
</li>
<li><p>其中参数1：指令的名称，注意，在定义的时候，指令的名称前面，不需要加 -v 前缀</p>
</li>
<li><p>但是在调用的时候，必须在指令名称前加上 v- 前缀 进行调用</p>
</li>
<li><p>参数2：是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'focus'</span>,&#123;</span><br><span class="line">	bind:<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;  =&gt;每当指令绑定到元素身上的时候，会立即执行这个bind函数，只执行一次</span><br><span class="line">		<span class="comment">//1.注意：在每个函数中，第一个参数永远是el，表示被绑定的那个元素，这个el参数以一个原生JS对象</span></span><br><span class="line">		<span class="comment">//2.在元素刚绑定指令的时候，还没有插入到DOM中，这时候，调用focus方法没有起作用</span></span><br><span class="line">		<span class="comment">//3.因为，一个元素只有插入到DOM中，才能获取焦点</span></span><br><span class="line">		<span class="comment">//el.focus()</span></span><br><span class="line">	&#125;,</span><br><span class="line">	inserted:<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;  =&gt;表示元素被插入到DOM中的时候，触发这个inserted函数，触发一次</span><br><span class="line">		el.focus()</span><br><span class="line">	&#125;,</span><br><span class="line">	updated:<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;  =&gt;每当VNode更新的时候，会执行updated函数，可能会被触发多次 </span><br><span class="line">		</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义指令简写:<pre><code class="Vue.directive(&#39;focus&#39;,function(el,binding){})"></code></pre>
</li>
<li>钩子函数的参数:<ul>
<li>指令钩子函数会被传入以下实参</li>
<li>1.el : 指令所绑定的元素，可以用来直接操作 DOM </li>
<li>2.binding:<ul>
<li>name: 指令名，<code>不包括 v- 前缀</code>;</li>
<li>value:指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 <code>2</code>;</li>
<li>expression:字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 <code>&quot;1 + 1&quot;</code></li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    



    
    <div>
    

    



    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </div></article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.jpg" alt="yiYe">
            
              <p class="site-author-name" itemprop="name">yiYe</p>
              <p class="site-description motion-element" itemprop="description">一土一业</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/wangyiye" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="airolwangya@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yiYe</span>

  
</div>


  <!--<div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>-->



 <!-- <span class="post-meta-divider">|</span>-->



  <!--<div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>-->




        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>      
    

    

  </div>

  <div class="bg_content">
    <canvas id="canvas"></canvas>
</div>



  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  




  
    <script id="cy_cmt_num" src="https://changyan.sohu.com/upload/plugins/plugins.list.count.js?clientId=cytxCyGhU"></script>
  









  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("5lgQ7QMn95h1aTv2FkBbgtEz-gzGzoHsz", "ioNcmgmuTgxMPWhT1r5te6yw");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  



</body>
</html>
